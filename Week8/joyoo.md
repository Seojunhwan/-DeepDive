# Week 8

# Quiz

### 40. 이벤트

1. 이벤트가 발생했을 때 호출될 함수를 _ _ _  _ _ _라 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 _ _ _  _ _ _  _ _이라 한다.
2. 이벤트 핸들러를 등록하는 방법 3가지는?
3. DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 _ _ _  _ _라고 한다.

### 41. 타이머

1. 다음 코드는 몇 초만에 실행되고 종료되는가? (2초/3초) 그 이유는?

```jsx
setTimeout(() => console.log("first!"), 1000); // 1초
setTimeout(() => console.log("second!"), 2000); // ?초
```

1. 디바운스와 스로틀의 차이는??

### 42. 비동기 프로그래밍

1. 동기 프로그래밍과 비동기 프로그래밍의 장단점은?
2. 콜스택, 힙, 태스크 큐, 이벤트 루프의 역할은?

### 43. Ajax

1. Ajax가 도입된 이후로 웹페이지가 발전된 부분에 대하여 데이터 통신, 렌더링, 블로킹 부분에서 설명해보자!
2. JSON의 직렬화와 역직렬화가 필요한 이유는?

# 정답

### 40.

1. 이벤트 핸들러, 이벤트 핸들러 등록
2. 이벤트 핸들러 어트리뷰트 방식, 이벤트 핸들러 프로퍼티 방식, addEventListener 메서드 방식
3. 이벤트 전파

### 41.

1. 2초. setTimeout은 비동기 처리 방식으로 동작하므로, 첫 번째 함수 실행이 끝나고 두 번째 함수가 호출되지 않고 각각 따로 호출되어 동작한다.
2. 디바운스: 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다. 
쓰로틀: 짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다.

### 42.

1. 동기 처리 방식
    
    장점: 실행 순서가 보장된다. 
    단점: 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다.
    
    비동기 처리 방식
    
    장점: 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않는다.
    단점: 태스크의 실행 순서가 보장되지 않는다.
    
2. 자바스크립트 엔진의 2개의 영역: 콜 스택, 힙
    
    콜 스택: 소스 코드가 추가되고 제거되는 스택 자료구조인 실행 컨텍스트 스택.
    
    힙: 객체가 저장되는 메모리 공간.
    
    브라우저 또는 Node.js가 담당: 태스크 큐, 이벤트 루프
    
    태스크 큐: 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역
    
    이벤트 루프: 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 확인하고, 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.
    

### 43.

# 40. 이벤트

- 이벤트 드리븐 프로그래밍
    
    브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다.
    
    이벤트가 발생했을 때 호출될 함수를 이벤트 핸들러라 하고, 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 이벤트 핸들러 등록이라 한다.
    
    Window, Document, HTMLElement 타입의 객체는 onclick과 같이 특정 이벤트에 대응하는 다양한 이벤트 핸들러 프로퍼티를 가지고 있다.
    
    이벤트와 그에 대응하는 함수를 통해 사용자와 애플리케이션은 상호작용할 수 있으며, 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라 한다.
    
- 이벤트 타입
    - 마우스 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | click | 마우스 버튼을 클릭했을 때 |
        | dblclick | 마우스 버튼을 더블 클릭했을 때 |
        | mousedown | 마우스 버튼을 눌렀을 때 |
        | mouseup | 누르고 있던 마우스 버튼을 놓았을 때 |
        | mousemove | 마우스를 움직였을 때 |
        | mouseenter | 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링되지 않는다) |
        | mouseover | 마우스 커서를 HTML 요소 안으로 이동했을 때(버블링된다) |
        | mouseleave | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링되지 않는다) |
        | mouseout | 마우스 커서를 HTML 요소 밖으로 이동했을 때(버블링된다) |
    - 키보드 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | keydown | 모든 키를 눌렀을 때 발생한다. |
        | keypress | 문자 키를 눌렀을 때 연속적으로 발생한다. |
        | keyup | 누르고 있던 키를 놓았을 때 한 번만 발생한다. |
    - 포커스 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | focus | HTML 요소가 포커스를 받았을 때(버블링되지 않는다) |
        | blur | HTML 요소가 포커스를 잃었을 때(버블링되지 않는다) |
        | focusin | HTML 요소가 포커스를 받았을 때(버블링된다) |
        | focusout | HTML 요소가 포커스를 잃었을 때(버블링된다) |
    - 폼 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | submit | 1. form 요소 내의 input, select 입력 필드 키를 눌렀을 때
        2. form 요소 내의 submit 버튼을 클릭했을 때 |
        | reset | form 요소 내의 reset 버튼을 클릭했을 때(최근에는 사용하지 않음) |
    - 값 변경 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | input | input(text, checkbox, radio), select, textarea 요소의 값이 입력되었을 때 |
        | change | input(text, checkbox, radio), select, textarea 요소의 값이 변경되었을 때 |
        | readystatechange | HTML 문서의 로드와 파싱 상태를 나타내는 document.readyState 프로퍼티 값(’loading’, ‘interactive’, ‘complete’)이 변경될 때 |
    - DOM 뮤테이션 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | DOMContentLoaded | HTML 문서의 로드와 파싱이 완료되어 DOM 생성이 완료되었을 때 |
    - 뷰 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | resize | 브라우저 윈도우(window)의 크기를 리사이즈할 때 연속적으로 발생한다. |
        | scroll | 웹페이지(document) 또는 HTML 요소를 스크롤할 때 연속적으로 발생한다. |
    - 리소스 이벤트
        
        
        | 이벤트 타입 | 이벤트 발생 시점 |
        | --- | --- |
        | load | DOMContentLoaded 이벤트가 발생한 이후, 모든 리소스(이미지, 폰트 등)의 로딩이 완료되었을 때(주로 window 객체에서 발생) |
        | unload | 리소스가 언로드될 때(주로 새로운 웹페이지를 요청한 경우) |
        | abort | 리소스 로딩이 중단되었을 때 |
        | error | 리소스 로딩이 실패했을 때 |
- 이벤트 핸들러 등록
    - 이벤트 핸들러 어트리뷰트 방식
        
        HTML 요소의 어트리뷰트를 이용한다. 
        
        ```html
        <!DOCTYPE html>
        <html>
        
        <body>
            <button onclick="sayHi('Lee')">Click me!</button>
            <script>
                function sayHi(name) {
                    console.log(`Hi ${name}.`);
                }
            </script>
        </body>
        
        </html>
        ```
        
        이벤트 핸들러 어트리뷰트 값으로 함수 참조가 아닌 함수 호출문 등의 문을 할당한다.
        
        이벤트 핸들러 어트리뷰트 방식은 오래된 코드에서 이 방식을 사용한 것이 있기 때문에 알아둘 필요는 있지만 더는 사용하지 않는 것이 좋다. HTML과 자바스크립트는 혼재하는 것보다 분리하는 것이 좋기 때문.
        
        하지만 모던 자바스크립트에서는 이벤트 핸들러 어트리뷰트 방식을 이용하는 경우가 있다.
        
    - 이벤트 핸들러 프로퍼티 방식
        
        window 객체와 Document, HTMLElement 타입의 DOM 노드 객체는 이벤트에 대응하는 이벤트 핸들러 프로퍼티를 가지고 있다. 
        
        ```html
        <!DOCTYPE html>
        <html>
        
        <body>
            <button>Click me!</button>
            <script>
                const $button = document.querySelector('button');
        
                // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
                $button.onclick = function () {
                    console.log('button click');
                }
            </script>
        </body>
        
        </html>
        ```
        
        이벤트 핸들러를 등록하기 위해서는 이벤트를 발생시킬 객체인 이벤트 타깃과 이벤트의 종류를 나타내는 문자열인 이벤트 타입, 이벤트 핸들러를 지정할 필요가 있다. 
        
        이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.
        
    - addEventListener 메서드 방식
        
        EventTarget.prototype.addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.
        
        ```html
        <!DOCTYPE html>
        <html>
        
        <body>
            <button>Click me!</button>
            <script>
                const $button = document.querySelector('button');
        
                // // 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩
                // $button.onclick = function () {
                //     console.log('button click');
                // }
        
                // addEventListener 메서드 방식
                $button.addEventListener('click', function () {
                    console.log('button click');
                })
            </script>
        </body>
        
        </html>
        ```
        
        이벤트 핸들러 프로퍼티 방식은 이벤트 핸들러 프로퍼티에 이벤트 핸들러를 바인딩하지만 addEventListener 메서드에는 이벤트 핸들러를 인수로 전달한다.
        
        addEventListener 메서드와 이벤트 핸들러 프로퍼티 방식을 다 사용할 경우 다 적용된다.
        
        addEventListener는 하나 이상의 이벤트 핸들러를 등록할 수 있다. 
        
- 이벤트 핸들러 제거
    
    addEventListener 메서드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventListener 메서드를 사용한다.
    
    removeEventListener 메서드에 인수로 전달한 이벤트 핸들러는 addEventListener 메서드에 인수로 전달한 등록 이벤트 햄들러와 동일한 함수이어야 한다. 즉, 무명함수를 등록한 경우 제거할 수 없다.
    
- 이벤트 객체
    
    이벤트가 발생하면 이벤트 객체가 동적으로 생성되며, 이벤트 핸들러의 첫 번째 인수로 전달된다.
    
    - 이벤트 객체의 상속 구조
        
        이벤트가 발생하면 이벤트 타입에 따라 다양한 타입의 이벤트 객체가 생성된다. 
        
        이벤트가 발생하면 암묵적으로 생성되는 이벤트 객체도 생성자 함수에 의해 생성된다. 그리고 생성된 이벤트 객체는 생성자 함수와 더불어 생성되는 프로토타입으로 구성된 프로토타입 체인의 일원이 된다.
        
    - 이벤트 객체의 공통 프로퍼티
        
        Event 인터페이스의 이벤트 관련 프로퍼티는 모든 이벤트 객체가 상속받는 공통 프로퍼티다.
        
    - 마우스 정보 취득
        
        click, dblclick, mousedown, mouseup, mouseenter, mouseleave 이벤트가 발생하면 생성되는 MouseEvent 타입의 이벤트 객체는 다음과 같은 고유의 프로퍼티를 갖는다.
        
        1. 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pagex/pageY, offsetX/offsetY
        2. 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button
    - 키보드 정보 취득
        
        keydown, keyup, keypress 이벤트가 발생하면 생성되는 KeyboardEvent 타입의 이벤트 객체는 altKey, ctrlKey, shiftKey, metaKey, key, keyCode 같은 고유의 프로퍼티를 갖는다.
        
- 이벤트 전파
    
    DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.
    
    1. 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
    2. 타깃 단계: 이벤트가 이벤트 타깃에 도달
    3. 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파
    
    → 이벤트는 이벤트를 발생시킨 이벤트 타깃은 물론 상위 DOM 요소에서도 캐치할 수 있다. 
    
- 이벤트 위임
    
    여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법.
    
    이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때 주의할 점은 상위 요소에 이벤트 핸들러를 등록하기 위해 이벤트 타깃, 즉 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐 수도 있다는 것이다. 따라서 이벤트 반응이 필요한 DOM에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.
    
- DOM 요소의 기본 동작 조작
    - DOM 요소의 기본 동작 중단
        
        이벤트 객체의 preventDefault 메서드는 DOM 요소의 기본 동작을 중단시킨다.
        
    - 이벤트 전파 방지
        
        stopPropagation 메서드는 하위 DOM 요소의 이벤트를 개별적으로 처리하기 위해 이벤트의 전파를 중단시킨다.
        
- 이벤트 핸들러 내부의 this
    - 이벤트 핸들러 어트리뷰트 방식
        
        onclick=handleClick(), handleClick 함수 내에서 this를 출력할 경우 handleClick은 일반 함수로 호출되며, 일반함수에서 호출된 this는 전역 객체를 가리킨다.
        
        onclick=handleClick(this)와 같이 인수로 전달한 this는 이벤트를 바인딩한 DOM 요소를 가리킨다.
        
    - 이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식
        
        두 가지 모두 this가 이벤트를 바인딩한 DOM 요소를 가리킨다. 즉, 이벤트 핸들러 내부의 this는 이벤트 객체의 currentTarget 프로퍼티와 같다. 
        
        화살표 함수로 정의한 이벤트 핸들러 내부의 this는 상위 스코프의 this를 가리킨다.
        
- 이벤트 핸들러에 인수 전달
    
    함수에 인수를 전달하려면 함수를 호출할 때 전달해야 한다. 이벤트 핸들러 어트리뷰트 방식은 함수 호출문을 사용할 수 있기 때문에 인수를 전달할 수 있지만 이벤트 프로퍼티 방식과 addEventListener 메서드 방식의 경우 이벤트 핸들러를 브라우저가 호출하기 때문에 함수 호출문이 아닌 함수 자체를 등록해야 한다. 따라서 인수를 전달할 수 없다. 그러나 인수를 전달할 방법이 전혀 없는 것은 아니다. 다음 예제와 같이 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달할 수 있다. 
    
- 커스텀 이벤트
    - 커스텀 이벤트 생성
        
        명시적으로 생성한 이벤트 객체는 임의의 이벤트 타입을 지정할 수 있으며, 개발자의 의도로 생성된 이벤트를 커스텀 이벤트라 한다.
        
        ```jsx
        // KeyboardEvent 생성자 함수로 keyup 이벤트 타입의 커스텀 이벤트 객체를 생성
        const keyboardEvent = new KeyboardEvent('keyup');
        console.log(keyboardEvent.type); // keyup
        
        // CustomEvent 생성자 함수로 foo 이벤트 타입의 커스텀 이벤트 객체를 생성
        const customEvent = new CustomEvent('foo');
        console.log(customEvent.type); // foo
        ```
        
        생성된 커스텀 이벤트 객체는 버블링되지 않으며 preventDefault 메서드로 취소할 수 없다.
        
    - 커스텀 이벤트 디스패치
        
        생성된 커스텀 이벤트는 dispatchEvent 메서드로 디스패치(이벤트를 발생시키는 행위)할 수 있다. 
        
        ```html
        <!DOCTYPE html>
        <html>
        
        <body>
            <button class="'btn">Click me</button>
            <script>
                const $button = document.querySelector('.btn');
        
                // 버튼 요소에 foo 커스텀 이벤트 핸들러를 등록
                // 커스텀 이벤트를 디스패치하기 이전에 이벤트 핸들러를 등록해야 한다.
                $button.addEventListener('click', e => {
                    console.log(e); // MouseEvent {isTrusted: false, screenX: 0, ... }
                    alert(`${e} Clicked!`);
                })
        
                // 커스텀 이벤트 생성
                const customEvent= new MouseEvent('click');
        
                // 커스텀 이벤트 디스패치(동기 처리). click 이벤트가 발생한다.
                $button.dispatchEvent(customEvent);
            </script>
        </body>
        
        </html>
        ```
        

# 41. 타이머

- 호출 스케줄링
    
    함수를 명시적으로 호출하면 함수가 즉시 실행된다. 만약 함수를 명시적으로 호출하지 않고 일정 시간이 경과된 이후에 호출되도록 함수 호출을 예약하려면 타이머 함수를 사용한다. 이를 호출 스케줄링이라 한다.
    
    자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖기 때문에 두 가지 이상의 태스크를 동시에 실행할 수 없다. 즉, 자바스크립트 엔진은 싱글 스레드로 동작한다. 이런 이유로 타이머 함수 setTimeout과 setInterval은 비동기 처리 방식으로 동작한다.
    
- 타이머 함수
    - setTimeout / clearTimeout
        
        setTimeout 함수는 두 번째 인수로 전달받은 시간으로 단 한 번 동작하는 타이머를 생성한다. 이후 타이머가 만료되면 첫 번째 인수로 전달받은 콜백 함수가 호출된다. 
        
        setTime 함수는 생성된 타이머를 식별할 수 있는 고유한 타이머 id를 반환하며, 이를 clearTimeout 함수의 인수로 전달하여 타이머를 취소할 수 있다.
        
        ```jsx
        const timerId = setTimeout(() => console.log('Hi!'), 1000);
        
        clearTimeout(timerId);
        ```
        
    - setInterval / clearInterval
        
        setInterval 함수는 두 번째 인수로 전달받은 시간으로 반복 동작하는 타이머를 생성한다. 마찬가지로 고유한 타이머 id를 반환하며, clearInterval로 취소할 수 있다. 
        
- 디바운스와 스로틀
    
    scroll, resize, input, mousemove 같은 이벤트는 짧은 시간 간격으로 연속해서 발생하므로 이벤트 핸들러가 과도하게 호출되어 성능에 문제를 일으킬 수 있다. 디바운스와 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 과도한 이벤트 핸들러의 호출을 방지하는 프로그래밍 기법이다.
    
    - 디바운스
        
        짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출하지 않다가 일정 시간이 경과한 이후에 이벤트 핸들러가 한 번만 호출되도록 한다. 즉, 짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.
        
    - 스로틀
        
        짧은 시간 간격으로 이벤트가 연속해서 발생하더라도 일정 시간 간격으로 이벤트 핸들러가 최대 한 번만 호출되도록 한다. 즉, 스로틀은 짧은 시간 간격으로 연속해서 발생하는 이벤트를 그룹화해서 일정 시간 단위로 이벤트 핸들러가 호출되도록 호출 주기를 만든다.
        

# 42. 비동기 프로그래밍

- 동기 처리와 비동기 처리
    
    다음 예제의 foo 함수와 bar 함수는 호출된 순서대로 스택 자료구조인 실행 컨텍스트 스택에 푸시되어 실행된다.
    
    함수가 실행되려면 “함수 코드 평가 과정”에서 생성된 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되어야 한다. 다시 말해, 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 바로 함수 실행의 시작을 의미한다. 함수가 호출된 순서대로 순차적으로 실행되는 이유는 함수가 호출된 순서대로 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시되기 때문이다. 이처럼 함수의 실행 순서는 실행 컨텍스트 스택으로 관리한다.
    
    자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 이는 하뭇를 실행할 수 있는 창구가 단 하나이며, 동시에 2개 이상의 함수를 동시에 실행할 수 없다는 것을 의미한다. 실행 컨텍스트 스택의 최상위요소인 “실행 중인 실행 컨텍스트”를 제외한 모든 실행 컨텍스트는 모두 실행 대기중인 태스크들이다. 대기 중인 대스크들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거되면, 다시 말해 현재 실행 중인 함수가 종료하면 비로소 실행되기 시작한다.
    
    이처럼 자바스크립트 엔진은 한 번에 하나의 태스크만 실행할 수 있는 싱글 스레드 방식으로 동작한다. 싱글 스레드 방식은 한 번에 하나의 태스크만 실행할 수 있기 때문에 처리에 시간이 걸리는 태스크를 실행하는 경우 블로킹이 발생한다. 예를 들어 setTimeout 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하는 sleep 함수를 구현해보자. 
    
    위 예제의 sleep 함수는 3초 후에 foo 함수를 호출한다. 이때 bar 함수는 sleep 함수의 실행이 종료된 이후에 호출되므로 3초 이상 호출되지 못하고 블로킹된다.
    
    이처럼 현재 실행 중인 태스크가 종료할 때까지 다음에 실행될 태스크가 대기하는 방식을 동기 처리라고 한다. 동기 처리 방식은 태스크를 순서대로 하나씩 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있다.
    
    위 예제를 타이머 함수인 setTimeout을 사용하여 수정해보자.
    
    setTimeout 함수는 앞서 살펴본 sleep 함수와 유사하게 일정 시간이 경과한 이후에 콜백 함수를 호출하지만 setTimeout 함수 이후의 태스크를 블로킹하지 않고 곧바로 실행한다. 이처럼 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식을 비동기 처리라고 한다.
    
    동기 처리 방식은 태스크를 순서대로 하났기 처리하므로 실행 순서가 보장된다는 장점이 있지만, 앞선 태스크가 종료할 때까지 이후 태스크들이 블로킹되는 단점이 있었다. 비동기 처리 방식은 현재 실행 중인 태스크가 종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하므로 블로킹이 발생하지 않는다는 장점이 있지만, 태스크의 실행 순서가 보장되지 않는 단점이 있다.
    
    비동기 처리를 수행하는 비동기 함수는 전통적으로 콜백 패턴을 사용한다. 비동기 처리를 위한 콜백 패턴은 콜백 헬을 발생시켜 가독성을 나쁘게 하고, 비동기 처리 중 발생한 에러의 예외 처리가 곤란하며, 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있다. 이에 대해서는 45절 “프로미스”에서 자세히 살펴보자.
    
    타이머 함수인 setTimeout과 setInterval, HTTP 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작한다.
    
    비동기 처리는 이벤트 루프와 태스크 큐와 깊은 관계가 있다. 
    
- 이벤트 루프와 태스크 큐
    
    자바스크립트의 특징 중 하나는 싱글 스레드로 동작한다는 것이다. 앞서 살펴본 바와 같이 싱글 스레드 방식은 한 번에 하나의 태스크만 처리할 수 있다는 것을 의미한다. 하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다.
    
    예를 들어, HTML 요소가 애니메이션 효가를 통해 움직이면서 이벤트를 처리하기도 하고, HTTP 요청을 통해 서버로부터 데이터를 가지고 오면서 렌더링하기도 한다. 이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프다.
    
    이벤트 루프는 브라우저에 내장되어 있는 기능 중 하나다. 브라우저 환경을 그림으로 표현하면 다음과 같다.
    
    구글의 V8 자바스크립트 엔진을 비롯한 대부분의 자바스크립트 엔진은 크게 2개의 영역으로 구분할 수 있다.
    
    1. 콜 스택
    2. 힙
    
    이처럼 콜 스택과 힙으로 구성되어 있는 자바스크립트 엔진은 단순히 태스크가 요청되면 콜 스택을 통해 요청된 작업을 순차적으로 실행할 뿐이다. 비동기 처리에서 소스코드의 평가와 실행을 제외한 모든 처리는 자바스크립트 엔진을 구동하는 환경인 브라우저 또는 Node.js가 담당한다. 예를 들어, 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다. 이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다.
    
    1. 태스크 큐
        
        : setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.
        
    2. 이벤트 루프
        
        : 콜스택에 현재 실행중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복적으로 확인하며, 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다.
        
    
    이처럼 비동기 함수인 setTimeout의 콜백 함수는 태스크 큐에 푸시되어 대기하다가 콜 스택이 비게 되면, 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 비로소 콜 스택에 푸시되어 실행된다.
    
    자바스크립트는 싱글 스레드 방식으로 동작한다. 이때 싱글 스레드 방식으로 동작하는 것은 브라우저가 아니라 브라우저에 내장된 자바스크립트 엔진이라는 것에 주의하기 바란다. 만약 모든 자바스크립트 코드가 자바스크립트 엔진에서 싱글 스레드 방식으로 동작한다면 자바스크립트는 비동기로 동작할 수 없다. 즉, 자바스크립트 엔진은 싱글 스레드로 동작하지만 브라우저는 멀티 스레드로 동작한다.
    

# 43. Ajax

- Ajax란?
    
    자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다.
    
- JSON
    
    JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다. 자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷으로, 대부분의 프로그래밍 언어에서 사용할 수 있다.
    
    - JSON 표기 방식
        
        JSON의 키는 반드시 큰따옴표로 묶어야 한다. 값은 객체 리터럴과 같은 표기법을 그대로 사용할 수 있다. 하지만 문자열은 반드시 큰따옴표로 묶어야 한다.
        
    - JSON.stringify
        
        객체를 JSON 포맷의 문자열로 변호나한다. 클라이언트가 서버로 객체를 전송하려면 객체를 문자열화해야 하는데 이를 직렬화라 한다.
        
        JSON.stringify 메서드는 객체 뿐만 아니라 배열도 JSON 포맷의 문자열로 변환한다.
        
    - JSON.parse
        
        JSON.parse 메서드는 JSON 포맷의 문자열을 객체로 변환한다. 서버로부터 클라이언트에게 전송된 JSON 데이터는 문자열이다. 이 문자열을 객체로서 사용하려면 JSON 포맷의 문자열을 객체화해야 하는데 이를 역직렬화라 한다.
        
- XMLHttpRequest
    
    브라우저는 주소창이나 HTML의 form 태그 또는 a 태그를 통해 HTTP 요청 전송 기능을 기본 제공한다. 자바스크립트를 사용하여 HTTP 요청을 전송하려면 XMLHttpRequest 객체를 사용한다.
    
    - XMLHttpRequest 객체 생성
        
        ```jsx
        const xhr = new XMLHttpRequest();
        ```
        
    - XMLHttpRequest 객체의 프로퍼티와 메서드
    - HTTP 요청 전송
        1. XMLHttpRequest.prototype.open 메서드로 HTTP 요청을 초기화한다.
        2. 필요에 따라 XMLHttpRequest.prototype.setRequestHeader 메서드로 특정 HTTP 요청의 헤더 값을 설정한다.
        3. XMLHttpRequest.prototype.send 메서드로 HTTP 요청을 전송한다.
    - HTTP 응답 처리

# 44. REST API

REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.

- REST API의 구성
    
    REST API는 자원, 행위, 표현의 3가지 요소로 구성된다. 
    
- REST API 설계 원칙
    1. URI는 리소스를 표현해야 한다.
        
        URI는 리소스를 표현하는 데 중점을 두어야 한다. 리소스를 식별할 수 있는 이름은 동사보다는 명사를 사용한다. 따라서 이름에 get 같은 행위에 대한 표현이 들어가서는 안 된다.
        
    2. 리소스에 대한 행위는 HTTP 요청 메서드로 표현한다.
        
        HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적을 알리는 방법이며, 주로 5가지 요청 메서드를 사용하여 CRUD를 구현한다.
        
- JSON Server를 이용한 REST API 실습
    - JSON Server 설치
    - db.json 파일 생성
    - JSON Server 실행
    - GET 요청
    - POST 요청
    - PUT 요청
    - PATCH 요청
    - DELETE 요청