# Week 6

# Quiz

34장.

1. 이터러블은 for … of 문으로 순회할 수 있으며 _ _ _ _  _ _과 _ _  _ _ _ _ _ _  _ _의 대상으로 사용할 수 있다.
2. for … of는 _ _ _ _을 순회하며, for … in은 _ _를 순회한다.

35장.

1. 스프레드 문법의 결과는 변수에 할당할 수 없다. 그 이유는 무엇인지 설명해보자!
2. 스프레드 문법은 Rest 파라미터와 형태가 동일하여 혼동할 수 있다. 둘의 차이는 무엇일까?

36장.

1. 배열 디스트럭처링 할당의 대상은 _ _ _ _이어야 하며 할당 기준은 배열의 _ _ _이다.
2. 객체 디스트럭처링 할당의 대상은 _ _이어야 하며 할당 기준은 _ _ _ _  _다.
3. 에러가 발생하는 부분을 모두 고르시오.

```jsx
const [x1, y1];                 // 1
const [x2, y2] = {};            // 2
const [x3, y3] = [];            // 3
const [x4, y4] = [1, 2, 3, 4];  // 4
const { x5, y5 };               // 5
const { x6, y6 } = null;        // 6
```

37장.

다음 중 옳지 않은 것을 ***모두*** 골라보세요!

1. Set 객체는 요소 순서에 의미가 없다.
2. Set의 size 프로퍼티와 Map의 size 프로퍼티는 setter 함수가 없어 size 프로퍼티로 Set 객체의 요소 개수를 변경할 수 없다.
3. Set의 add 메서드와 Map의 set 메서드는 새로운 객체를 반환하므로 메서드를 호출한 후 메서드를 연속적으로 호출할 수 있다.
4. Set와 Map의 delete 메서드는 Set 객체의 특정 요소를 삭제하는데 사용되며 add와 마찬가지로 연속적으로 호출할 수 있다.
5. 존재하지 않는 Set 객체의 요소 혹은 Map 객체의 요소를 삭제하려 하면 에러 없이 무시되고 true를 반환한다.
6. Set 객체의 요소를 순회하는 forEach 메서드는 3개의 인수를 전달받을 수 있으며, 첫 번째 인수와 두 번째 인수는 일치하는 값이다.
7. 자바스크립트는 교집합, 합집합, 차집합 등의 집합 연산을 지원하는 내부 메서드가 존재한다.
8. Map 객체는 이터러블이고, 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.

# 34. 이터러블

- 이터레이션 프로토콜
    
    순회 가능한 데이터 컬렉션을 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙. 이터러블 프로토콜과 이터레이터 프로토콜이 있다.
    
    - 이터러블
        
        이터러블 프로토콜을 준수한 객체를 이터러블이라 한다. 이터러블은 for … of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있다. 
        
    - 이터레이터
        
        이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 next 메서드를 갖는다.
        
- 빌트인 이터러블
    1. Array
    2. String
    3. Map
    4. Set
    5. TypedArray
    6. Arguments
    7. DOM 컬렉션
- for … of 문
- 이터러블과 유사 배열 객체
    
    배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체.
    
    for … of 문으로 순회할 수 없다.
    
- 이터레이션 프로토콜의 필요성
    
    이터레이션 프로토콜은 데이터 소비자와 데이터 공급자를 연결하는 인터페이스의 역할을 한다.
    
- 사용자 정의 이터러블
    - 사용자 정의 이터러블 구현
        
        이터레이션 프로토콜을 준수하도록 Symbol.iterator 메서드를 구현하고 next 메서드를 갖는 이터레이터를 반환하도록 한다. next 메서드는 done과 value 프로퍼티를 가지는 이터레이터 리절트 객체를 반환한다. 
        
    - 이터러블을 생성하는 함수
    - 이터러블이면서 이터레이터인 객체를 생성하는 함수
    - 무한 이터러블과 지연 평가

# 35. 스프레드 문법

스프레드 문법의 결과는 변수에 할당할 수 없다.

- 함수 호출문의 인수 목록에서 사용하는 경우
    
    요소들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우 스프레드 문법을 사용하면 좋다.
    
- 배열 리터럴 내부에서 사용하는 경우
    - concat
        
        2개의 배열을 1개의 배열로 결합하고 싶은 경우 concat 메서드를 사용해야 했으나, 스프레드 문법을 사용하면 별도의 메서드를 사용하지 않고 배열 리터럴만으로 2개의 배열을 1개의 배열로 결합할 수 있다.
        
    - splice
        
        어떤 배열의 중간에 다른 배열의 요소를 추가하거나 제거하려면 splice 메서드를 사용한다. 
        
        배열 내에 배열을 합치고 싶은 경우 Function.prototype.apply 메서드를 사용해야 하나, 스프레드 문법을 사용하면 더욱 간결하게 표현할 수 있다.
        
    - 배열 복사
        
        원래 배열을 복사하려면 slice 메서드를 사용했으나, 스프레드 문법으로 대체할 수 있다.
        
    - 이터러블을 배열로 변환
        
        이터러블을 배열로 변환하려면 Function.prototype.apply 또는 [Function.prototype.call](http://Function.prototype.call) 메서드를 사용해야 했으나, 스프레드 문법으로 대체할 수 있다. 대신 스프레드 문법은 유사 배열 객체를 대상으로 삼을 수 없다.
        
- 객체 리터럴 내부에서 사용하는 경우

# 36. 디스트럭처링 할당

디스트럭처링 할당은 구조화된 배열과 같은 이터러블 또는 객체를 destructuring하여 1개 이상의 변수에 개별적으로 할당하는 것을 말한다.

- 배열 디스트럭처링 할당
    
    배열 디스트럭처링 할당의 대상은 이터러블이어야 하며, 할당 기준은 배열의 인덱스다.
    
    ```jsx
    // p.637
    const arr = [1, 2, 3];
    
    const [one, two, three] = arr;
    
    console.log(one, two, three); // 1 2 3
    ```
    
- 객체 디스트럭처링 할당
    
    객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다. 할당 기준은 프로퍼티 키다. 즉, 순서는 의미가 없으며 선언된 변수 이름과 프로퍼티 키가 일치하면 할당된다.
    
    ```jsx
    // p.639
    const user = { firstName: 'Ungmo', lastName: 'Lee' };
    
    const { lastName, firstName } = user;
    
    console.log(firstName, lastName); // Ungmo Lee
    ```
    

# 37. Set과 Map

- Set
    
    중복되지 않는 유일한 값들의 집합
    
    - Set 객체의 생성
        
        ```jsx
        const set = new set();
        console.log(set); // Set(0) {}
        ```
        
        Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.
        
    - 요소 개수 확인
        
        Set.prototype.size 프로퍼티를 사용한다.
        
        ```jsx
        const { size } = new Set([1, 2, 3, 3]);
        console.log(size);
        ```
        
    - 요소 추가
        
        Set.prototype.add 메서드를 사용한다.
        
        add 메서드는 새로운 요소가 추가된 Set 객체를 반환한다.
        
        Set 객체는 자바스크립트의 모든 값을 요소로 저장할 수 있다.
        
    - 요소 존재 여부 확인
        
        Set.prototype.has 메서드를 사용한다.
        
    - 요소 삭제
        
        Set.prototype.delete 메서드를 사용한다.
        
        delete 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 
        
    - 요소 일괄 삭제
        
        Set.prototype.clear를 사용한다. clear 메서드는 언제나 undefined를 반환한다.
        
    - 요소 순회
        
        Set.prototype.forEach 메서드를 사용한다.
        
        콜백 함수에 3개의 인수를 전달할 수 있다.
        
        → 첫 번째 인수 : 현재 순회 중인 요소값
        
        → 두 번째 인수 : 현재 순회 중인 요소값
        
        → 세 번째 인수 : 현재 순회 중인 Set 객체 자체
        
        첫 번째 인수와 두 번째 인수는 같은 값이며, Array.prototype.forEach 메서드와 인터페이스를 통일하기 위함이다. → 퀴즈
        
        Set 객체는 이터러블이므로 for … of 문으로 순회할 수 있으며, 스프레드 문법과 배열 디스트럭처링의 대상이 될 수도 있다.
        
    - 집합 연산
        
        위의 여러 Set 객체의 메서드를 이용하여 교집합, 합집합, 차집합 등을 구현할 수 있다.
        
- Map
    
    Map 객체는 키와 값의 쌍으로 이루어진 컬렉션이다. 
    
    - Map 객체의 생성
        
        Map 생성자 함수로 생성한다.
        
        ```jsx
        const map = new Map();
        console.log(map); // Map(0); {}
        ```
        
        Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.
        
    - 요소 개수 확인
        
        Map.prototype.size 프로퍼티를 사용한다.
        
    - 요소 추가
        
        Map.prototype.set 메서드를 사용한다. set 메서드는 새로운 요소가 추가된 Map 객체를 반환한다.
        
    - 요소 취득
        
        Map.prototype.get 메서드를 사용한다.
        
    - 요소 존재 여부 확인
        
        Map.prototype.has 메서드를 사용한다. has 메서드는 특정 요소의 존재 여부를 나타내는 불리언 값을 반환한다.
        
    - 요소 삭제
        
        Map.prototype.delete 메서드를 사용한다. delete 메서드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 
        
    - 요소 일괄 삭제
        
        Map.prototype.clear 메서드를 사용한다. clear 메서드는 언제나 undefined를 반환한다.
        
    - 요소 순회
        
        Map.prototype.forEach 메서드를 사용한다.
        
        Map 객체는 이터러블이고, 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메서드를 제공한다.
        

## 정답

34장.

1. 스프레드 문법, 배열 디스트럭처링 할당
2. 이터러블, 객체

35장.

1. 스프레드 문법의 결과값은 하나의 값이 아니라 값들의 목록이다. 즉 스프레드 문법 …이 피연산자를 연산하여 값을 생성하는 생성자가 아니다. 
2. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 …을 붙이는 것이고, 스프레드 문법은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것이다. 

36장.

1. 이터러블, 인덱스
2. 객체, 프로퍼티 키
3. 1, 2, 5, 6

37장.

4, 5, 7