# 모던 자바스크립트 Deep Dive

# 4장. 변수

- 사람 vs 자바스크립트 : 계산하는 방식
    - 계산 == 평가
    - 10, 20, + == 리터럴, 연산자
    - 10 + 20이라는 식 == 표현식
    - 해석 == 파싱
- 메모리 : 데이터를 저자할 수 있는 메모리 셀의 집합체.
    - 메모리 셀 하나의 크기는 1 바이트 == 8 비트
    - 메모리에 저장되는 모든 값은 2진수로 저장된다.
- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름.
    - 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 변수 이름이라 하고, 변수에 지정된 값을 변수 값이라고 한다.
    - 변수에 값을 저장하는 것을 할당이라 한다.
    - 변수 이름은 신중하게 지어야 한다. (개발자의 의도를 나타내는 명확한 네이밍
- 변수를 식별자라고도 하는데, 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.
    - 식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장되어야 한다.
    - 즉, 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다.
    - var 키워드에는 여러 단점이 있기에, ES6에서 let과 const 키워드가 나와서 var 키워드의 여러 단점을 보완했다.
- 변수 선언에 의해 확보된 메모리 공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다.
- 자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.
    - 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
    - 초기화 단계 : 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.
- 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행된다. → 변수 호이스팅
- 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.
    - 변수 선언 → 런타임 (위에서 아래로)

![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled.png)

→ undefined, 80이 순차적으로 출력된다.

- const 키워드를 활용하면 상수를 표현할 수 있다.
- 자바스크립트는 메모리의 할당 및 해제를 개발자가 직접할 수 없는 매니지드 언어이다.

Q. 다음 코드의 실행 결과는?

```jsx
console.log(a);
console.log(a + b);
a = 20;
console.log(a);
var a;
console.log(a + b);
var b;
b = 30;
console.log(a);
console.log(a + b);
```

- A.
    
    ```
    undefined
    NaN
    20
    NaN
    20
    50
    ```
    

# 5장. 표현식과 문

- 값은 식이 평가되어 생성된 결과를 말한다.
- 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
    - 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.
- 표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
    - 문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.
    - x = 1 + 2; x + 3;과 같이 써도 된다.
- 문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.
- 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.
- 문의 끝에 붙이는 세미콜론은 생략 가능하다. 자바스크립트 엔진이 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주기 때문이다. 하지만 세미콜론을 붙이지 않을 경우 때에 따라 자동삽입을 제대로 하지 못하는 경우가 있어 세미콜론을 붙이는 것이 권장된다.
- 표현식인 문과 표현식이 아닌 문
    - 표현식인 문은 값으로 평가될 수 있는 문이며, 표현식이 아닌 문은 값으로 평가될 수 없는 문이다.
    - 가장 간단하고 명료하게 문을 구별하는 방법은 변수에 할당해보는 것이다. 표현식인 문은 할당 가능, 표현식이 아닌 문은 할당 불가능.

Q. 

1. 표현식은 값으로 평가될 수 있는 문이기 위한 필요충분조건이다.
2. 변수 선언문은 표현식이다.
3. 표현식은 변수에 할당할 수 있다.
- A.
    
    True
    
    False
    
    True
    

# 6장. 데이터 타입

- 데이터 타입 종류
    - 숫자 타입
    - 문자열 타입
    - 불리언(boolean) 타입
    - undefined 타입
    - null 타입
    - 심볼(symbol) 타입
- 숫자 타입
    - 하나의 숫자 타입만 존재. (정수, 실수, 등등 다 통일)
    - 64비트 부동소수점 형식
    - 실수 타입만 존재하므로 1 == 1.0임.
    - Infinity, -Infinity, NaN (Not a Number)도 존재.
- 문자열 타입
    - 작은따옴표, 큰따옴표, 백틱으로 텍스트를 감싼다. 일반적인 표기법은 작은따옴표를 이용.
    - 따옴표로 감싸지 않을 경우 키워드나 식별자 같은 토큰으로 인식한다.
    - C는 문자열이 배열이고, 자바는 문자열이 객체이지만, 자바스크립트는 문자열이 원시 타입이고, 변경불가능한 값이다.
- 템플릿 리터럴
    - 일반적인 문자열과 비슷해보이지만 작은따옴표 또는 큰따옴표 같은 일반적인 따옴표 대신 백틱을 사용한다.
    - 일반적인 문자열에서는 줄바꿈이 허용되지 않으므로, 줄바꿈 등의 white space를 이용하려면 \로 시작하는 이스케이프 시퀀스를 사용해야 한다.
    - 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않고도 줄바꿈이 가능하고, 모든 공백도 있는 그대로 적용된다.
- 표현식 삽입
    - + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작하고, 그 외의 경우에는 덧셈 연산자로 작동한다.
    - 표현식을 삽입하려면 ${ }으로 표현식을 감싸면 된다. 이때 템플릿 리터럴 안에서만 취급이 되며, 일반 문자열에서의 표현식 삽입은 문자열로 취급된다.
- 불리언 타입
- undefined 타입
    - 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.
    - 변수에 값이 없다는 것을 명시하고 싶을 때는 null을 할당한다.
- null 타입
    - 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다.
- 심볼 타입
    - 변경불가능한 원시 타입의 값으로 다른 값과 중복되지 않는 유일무이한 값이다.
    - 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.
        
        ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%201.png)
        
- 객체 타입
    - 자바스크립트는 객체 기반의 언어이며, 자바스크립트를 이루고 있는 거의 모든 것이 객체이다.
- 데이터 타입의 필요성
    - 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해.
    - 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해.
    - 메모리에서 읽어들인 2진수를 어떻게 해석할 지 결정하기 위해.
- 동적 타이핑
    - 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.
    - 동적 타입 언어는 편리하지만, 구조적인 단점도 존재한다. 변화하는 변수 값을 추적하기 어려울 수 있고, 값의 변경에 의해 타입도 언제든지 변경될 수 있기 때문에 값을 확인하기 전에는 타입을 확신할 수 없다.
        
        → 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어진다.
        

Q. 

1. undefined와 null의 차이는?
2. 자바스크립트의 문자열은 변경 불가능한 값이다.
- A.
    1. undefined : var 키워드로 선언된 변수에 암묵적으로 할당되는 값.
    null : 값이 없다는 것을 의도적으로 명시할 때 사용하는 값.
    2. True. 자바스크립트의 문자열은 원시 타입이다.

# 7장. 연산자

- 산술 연산자
    - 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.
    - 이항 산술 연산자
        - 2개의 피연산자를 산술연산하여 숫자 값을 만든다.
        - 불가능할 경우 NaN을 반환한다.
        - 피연산자의 값을 변경하는 부수 효과가 없다.
    - 단항 산술 연산자
        - 1개의 피연산자를 산술연산하여 숫자 값을 만든다.
            
            ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%202.png)
            
            → 숫자 타입이 아닌 피연산자에 + 또는 - 단항 연산자를 사용하면 피연산자를 숫자타입으로 변환하여 반환한다.
            
    - 문자열 연결 연산자
        - + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
            
            ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%203.png)
            
- 할당 연산자
    - 할당 연산자는 우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당한다.
    
    ```jsx
    console.log(x = 10);
    ```
    
    - 위와 같은 경우 10을 출력한다. 할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.
- 비교연산자
    - 동등/일치 비교 연산자
        - 동등 비교 : == (불일치 : !=)
            
            → x와 y의 값이 같음
            
        - 일치 비교 : === (불일치 : !==)
            
            → x와 y의 값과 타입이 같음
            
        
        → 동등이 일치보다 느슨함. 즉 일치가 동등보다 엄격함.
        
        5 == ‘5’는 true. 5 === ‘5’는 false
        
        → 동등 비교는 그 결과가 예측하기 어렵고 실수하기 쉬우므로 사용하지 않는 편이 좋고 일치 비교를 사용하는 것이 좋다.
        
        → NaN은 자신과 일치하지 않는 유일한 값이므로, 어떤 숫자가 NaN인지 조사하려면 builtin 함수 Number.isNaN을 사용한다.
        
- 삼항 조건 연산자
    - 조건식의 평가 결과에 따라 반환할 값을 결정한다.
    
    ```jsx
    var result = x % 2 ? '홀수' : '짝수';
    ```
    
    - if-else 문은 표현식이 아닌 문이므로 값처럼 사용할 수 없고, 삼항연산자는 표현식인 문이므로 값처럼 사용할 수 있다.
- 논리 연산자
    - 우항과 좌항의 피연산자를 논리연산한다.
        
        ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%204.png)
        
- 쉼표 연산자
    - 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과 결과를 반환한다.
    
    ```jsx
    x = 1, y = 2, z = 3; // 3
    ```
    
- 그룹 연산자
    - 소괄호로 피연산자를 감싸는 그룹 연산자는 자신의 피연산자인 표현식을 가장 먼저 평가한다.
- typeof 연산자
    - 피연산자의 데이터 타입을 문자열로 반환한다.
        
        ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%205.png)
        
    - typeof null은 object임을 주의하자.
    - 선언하지 않은 식별자의 typeof 결과는 ReferenceError가 아닌 undefined이다.
- 지수 연산자
    - 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 반환한다.
        
        ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%206.png)
        
    - 음수를 거듭제곱의 밑으로 사용하려면 괄호로 묶어야 한다.
    
    ```jsx
    (-5) ** 2; // -> 25
    ```
    
    - 할당 연산자와 함께 사용할 수 있다.
    
    ```jsx
    var num = 5;
    num **= 2; // -> 25
    ```
    
    - 이항 연산자 중 우선순위가 가장 높다.
- 연산자 우선순위
    
    ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%207.png)
    
    ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%208.png)
    
    - 기억에 의존하기보다는 연산자 우선순위가 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.

Q. 다음 코드의 실행 결과는?

```jsx
var a = 1;
var b = 2;

console.log(++a ** b++);
console.log(a ** b);
console.log(a ** !b);
```

- A.
    
    ```
    4
    8
    1
    ```
    

# 8장. 제어문

- 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있으나, 순차적으로 진행하는 직관적인 코드의 흐름을 혼란스럽게 만든다.
- 블록문
    - 자바스크립트는 블록문을 하나의 실행단위로 취급한다.
- 조건문
    - if - else 문
        
        ```jsx
        if (조건식) {
        	// 조건식이 참이면 이 코드 블록이 실행된다.
        } else {
        	// 조건식이 거짓이면 이 코드 블록이 실행된다.
        }
        ```
        
        - 만약 코드 블록 내의 문이 하나라면 중괄호를 생략할 수 있다.
        - 대부분의 if - else 문은 삼항 조건 연산자로 바꿔 쓸 수 있다.
    - switch 문
        
        ```jsx
        switch (표현식) {
        	case 표현식1:
        		switch 문의 표현식과 표현식1이 일치하면 실행될 문;
        		break;
        	case 표현식2:
        		switch 문의 표현식과 표현식2가 일치하면 실행될 문;
        		break;
        	default:
        		switch 문의 표현식과 일치하는 case 문이 없을 때 실행될 문;
        }
        ```
        
        - 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 흐름을 옮긴다.
        - 논리적 참, 거짓보다는 다양한 상황에 따라 실행할 코드 블록을 결정할 때 사용한다.
        - 마지막 (통상은 default) 이전의 case 문 안에는 break문으로 switch문을 빠져나갈 필요가 있다.
- 반복문
    - for문
    
    ```jsx
    for (변수 선언문 또는 할당문; 조건식; 증감식) {
    	조건식이 참인 경우 반복 실행될 문;
    }
    ```
    
    - while문
    
    ```jsx
    while (조건식) {
    	조건식이 참인 경우 반복 실행될 문
    }
    ```
    
- break문
    - 레이블 문, 반복문 또는 switch 문의 코드 블록을 탈출한다.
- continue문
    - 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다.
    

Q.

1. while문과 do … while 문의 차이점은?
2. label 문을 이용해서 outer for문을 탈출하는 방법이 제시되어있으나, label 문은 가독성을 해치고 오류를 발생시킬 가능성이 높다고 적혀있다. label 문을 이용하지 않고 outer for문을 탈출할 방법은?
- A.
    1. while문은 조건에 따라 한 번도 실행되지 않을 수 있으나, do … while문은 우선 한 번 실행하고 조건을 확인하므로 한 번은 무조건 실행된다.
    2. 개인마다 다르겠으나, 필자는 flag 변수를 활용하여 flag가 true일 경우 outer for문이 계속 돌고 false일 경우 outer for문이 break되게 하는 법을 선호한다.

# 9장. 타입 변환과 단축 평가

- 타입 변환이란?
    - 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라고 한다.
    - 개발자의 의도와는 상관없이 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.
    - 타입 변환이 기존 원시 값의 자료형을 바꾸는 것은 아니고, 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것이다. 원시 값은 애초에 immutable하므로 변경이 되지 않는다.
- 암묵적 타입 변환
    - 문자열 타입으로 변환
        - + 연산자는 피연산자가 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작한다.
        - 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다.
            
            ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%209.png)
            
    - 숫자 타입으로 변환
        - -, *, /는 모두 산술 연산자이고 피연산자가 문맥상 모두 숫자 타입이어야 한다. 따라서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환하고, 변환할 수 없는 경우는 NaN이 된다.
        - 비교 연산자의 피연산자는 문맥상 모두 숫자 타입이어야 한다. 따라서 산술 연산자와 마찬가지이다.
            
            ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%2010.png)
            
            ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%2011.png)
            
    - 불리언 타입으로 변환
        - Truthy 값 또는 Falsy 값으로 구분된다.
        - Falsy 값
            - false
            - undefined
            - null
            - 0, -0
            - NaN
            - ‘’(빈 문자열)
        - 주의 : ‘0’은 빈 문자열이 아니므로 Truthy 값이다.
- 명시적 타입 변환
    - 문자열 타입으로 변환
        - String 생성자 함수를 new 연산자 없이 호출하는 방법
        - Object.prototype.toString 메서드를 사용하는 방법
        - 문자열 연결 연산자를 이용하는 방법
    - 숫자 타입으로 변환
        - Number 생성자 함수를 new 연산자 없이 호출하는 방법
        - parseInt, parseFloat 함수를 사용하는 방법
        - + 단항 산술 연산자를 이용하는 방법
        - * 산술 연산자를 이용하는 방법
    - 불리언 타입으로 변환
        - Boolean 생성자 함수를 new 연산자 없이 호출하는 방법
        - ! 부정 논리 연산자를 두 번 사용하는 방법
- 단축 평가
    - 논리 연산자를 사용한 단축 평가
        
        ![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%A5%E1%86%AB%20%E1%84%8C%E1%85%A1%E1%84%87%E1%85%A1%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3%20Deep%20Dive%20be23068115df4fd5ad488da9a5890d3b/Untitled%2012.png)
        
        - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때
        - 함수 매개변수에 기본 값을 설정할 때
    - 옵셔널 체이닝 연산자
        - ?. → 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때 유용함.
        - 0이나 ‘’(빈 문자열)은 객체로 평가될 때도 있다.
    - null 병합 연산자
        - ?? → 좌항의 피연산자가 null 또는 undefined인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.
        - null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환한다.

Q. 다음 코드의 실행 결과는?

```jsx
var x;
var y;
console.log(x);
console.log(y);
console.log(x + y);
x = "Hello";
console.log(x + y);
console.log((true || 3) + '' + (true && false) == (false || true) + (false || false) + '' ? 'Hello' : 'World')
```

- A.
    
    ```
    undefined
    undefined
    NaN
    Helloundefined
    World // -> ((false || false) + '')와 같이 괄호를 씌워준다면??
    ```