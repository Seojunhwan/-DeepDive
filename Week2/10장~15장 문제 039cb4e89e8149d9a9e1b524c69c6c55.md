# 10장~15장 문제

### 10장: 객체 리터럴

```jsx
다음 중 출력 결과가 제대로 나오지 않는 것은?

var person = {
	name: 'Kim'
};
```

```jsx
1. 
	var key = 'age';
	person[key] = 20;
	console.log(person.age); // 20

2. 
	person.name = 'Lee';
	console.log(person.name); //Lee

3.
	person.name = 'Choi';
	console.log(person.[name]); //Choi

4. 
	delete person.gender;
	console.log(person); //{name: 'Lee', age: 20}

5.
	let color = 'white';
	person = {color}
	console.log(person.color); // white
```

### **11장: 원시 값과 객체의 비교**

```jsx
다음 중 설명이 옳지 않은 것은?

1) 자바스크립트의 문자열은 원시타입으로 변경 불가능한 값이다.
2) 문자열은 유사배열객체이기 때문에 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있다. 
그러나 값은 바꿀 수 없다.
3) 식별자는 메모리 주소에 붙인 이름으로, 메모리 주소를 통해 메모리 공간에 저장된 값에 접근한다.
4) 객체를 할당한 변수를 참조하면 메모리에 저장되어 있는 참조값을 통해 실제 객체에 접근한다.
5) 객체를 가리키는 변수를 다른 변수에 할당하면 참조값을 복사하여 전달하기 때문에 
원본과 사본의 메모리 주소는 같고 동일한 참조값을 갖는다. 
```

### **12장: 함수**

```jsx
다음 주 아래의 함수에 대한 설명을 옳지 않은 것은?

var div2 = function foo (x , y) {
	return  x / y;
};

-

1) 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 표현식 방식으로 함수를 정의했다.
2) console.log(foo(10, 2))의 결과는 5이다
3) 함수 리터럴의 함수 이름은 생략 가능하기 때문에 아래와 같은 함수도 가능하다.
		var div2 = function (x , y) {
			return  x / y;
		};
4) 함수 선언문의 함수 이름은 생략할 수 없기 때문에 다음과 같은 함수는 불가능하다
		function (x , y) {
			return  x / y;
		};
5) 위 함수를 화살표 함수로 표현하면 다음과 같이 표현할 수 있다.
		const div2 = (x , y) => x / y;
```

### **13장: 스코프**

```jsx
다음 중 설명이 옳지 않은 것은?

1) 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이다.
2) var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다.
3) var 키워드는 함수 레벨 스코프만 인정하기 때문에 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었을지라도 모두 전역변수다
4) const와 let은 블록 레벨 스코프를 지원하기 때문에 const와 let으로 선언된 변수는 코드 블록 내에서만 유효하다
5) 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.
```

### **14장: 전역 변수의 문제점**

```jsx
다음 중 옳지 않은 것은?

1) 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다. 

2) 
var x = 'first';

function foo() {
		console.log(x);
		var x = 'second';
		console.log(x);
}

foo(); // undefined second

위와 같은 현상이 일어나는 이유는 호이스팅 때문이다.

3) 전역 변수의 사용을 억제하는 방법으로는 즉시 실행 함수, 네임 스페이스 객체, 모듈 패턴이 있다.

4) ES6 모듈을 사용해도 전역 변수는 사용할 수 있다.

```

### **15장: let, const 키워드와 블록 레벨 스코프**

```jsx
다음 중 옳지 않은 것은?

1) 
console.log(a); //undefined
a = 'a';
console.log(a); // a
var a;

2) 
console.log(a); //ReferenceError
a = 'a';
console.log(a);
let a;

3)
let a = 'a'; //ReferenceError
{
	console.log(a); 
	let a = 'b';
}

4) const로 선언한 변수는 반드시 선언과 동시에 초기화 해야한다.
5) var, const, let로 선언한 변수는 객체 window의 프로퍼티가 된다.
```