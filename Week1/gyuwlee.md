# Week 1 : CH.04 ~ 09

[바로 퀴즈로 넘어가기](#퀴즈)

<br/>

## CH04. 변수
### 1) 자바스크립트 엔진과 변수
```js
10 + 20
```
간단한 JS 코드를 아무거나 실행한다고 생각해 보자. 엔진은 위 `표현식` 에서 덧셈 `연산자` 와, 그 양 변의 숫자 `리터럴` 을 해석하여 전체 식을 `평가` 한다. 이렇게 엔진은 `표현식` 으로부터 `평가값` 을 도출해낼 수 있다. 그런데, **그 다음엔?**

위 식에서 리터럴 10과 20, 평가값 30은 각기 다른 메모리 공간에 저장되어 있다. 만약 우리가 두 리터럴을 연산해 얻은 평가값을 코드의 다른 곳에서 사용하고 싶다면, 어떻게 접근할 수 있을까?

값이 저장되는 메모리의 주소는 가변적이다. 컴퓨터의 재실행, 프로그램의 재실행 때마다 주소는 변경될 수 있다. 그래서 **`변수`** 를 사용한다.

자바스크립트에서 **변수**란, "값의 **위치**를 가리키는 상징적인 이름"이다. 즉, 개발자의 직접적인 메모리 제어를 허용하지 않고, 변수를 선언 및 사용하여서만 메모리에 접근할 수 있다. 

우리가 코드 내부에서 사용한 변수는, 인터프리터가 읽어들일 때 **값이 저장된 메모리 공간의 주소** 로 치환되어 실행된다.

사용자는 이러한 변수를 **할당** 과 **참조** 라는 두 가지 방식으로 사용할 수 있다:
- `할당` : 변수에 값을 저장하는 것
- **`참조` : 변수에 저장된 값을 읽어 들이는 것**

<br/>

### 2) 변수와 식별자
`식별자` 는 변수를 포함하는 개념이다. 식별자란 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 즉 값들 간의 차이를 알고 분별할 수 있게 해주는 이름이다. 

그러기 위해서는 식별자가 **값이 저장되어 있는 메모리 주소**를 알고 있어야 한다. 즉 값이 저장되어 있는 메로리 주소와 매핑 관계를 맺는다. **이 때, 이 매핑 정보도 메모리에 저장되어야 한다.**

**즉, 식별자는 값이 아니라 메모리 주소를 기억(저장)하고 있다.** 우리는 식별자에 값을 담았다고 생각하지만 사실 이 값은 **런타임** 과정에서 인터프리터가 식별자에 담긴 메모리 주소에 접근해야 비로소 불러와진다.

앞서 말했듯 식별자는 변수를 '포함' 하는 개념이다. 변수뿐만 아니라 함수, 클래스 등의 '이름' 은 모두 식별자다. 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다.

<br/>

### 3) 변수 선언
**그럼 변수를 선언하면 어떤 일이 생기는가?**
```js
var foo = 10; // typeof foo == Number
```

#### (1) 선언 단계
먼저, 선언된 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.

#### (2) 초기화 단계
등록된 변수 이름에 매핑할 메모리 공간이 확보된다. **이때 메모리 공간은 `undefined` 로 초기화된다.**

> 📌  **`undefined` 와 `null`**<br/>
`undefined` 는 '값이 할당되지 않은 상태’를 나타낼 때 사용한다. 변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined` 가 자동으로 할당된다. `null` 과 같이, 개발자가 명시적으로 변수에 `undefined` 를 할당하는 것도 가능하긴 하다. 그러나 관습적으로 `undefined` 는 값이 할당되지 않은 변수의 초기값을 표현하는 예약어로 사용된다. **변수가 '비어있거나', '알 수 없는' 상태라는 걸 나타내려면 `null` 을 사용한다.**

위의 두 단계를 거쳐야만 해당 변수를 코드의 다른 부분에서 사용할 수 있게 된다. 이렇게 선언되지 않은 변수(식별자)에 접근했을 때는 `ReferenceError` 가 발생한다. 

`reference` 라는 말뜻에서 알 수 있듯, 어떤 식별자의 이름을 통해 값을 참조하려 했지만 엔진에 해당 식별자가 등록되어 있지 않아 찾을 수 없을 때 발생하는 에러다.

그런데, 코드를 짜다 보면 `ReferenceError` 즉 에러를 뱉고 실행이 중단되어야 하는 상황임에도 **에러가 발생되지 않고 실행이 이어지는 경우** 가 발생할 수 있다. 이러한 경우 사용자가 정확히 어느 지점에서 코드가 오작동하고 있는지 알아내기 어려워진다. 그 중 하나가 **변수 호이스팅** 문제다.

<br/>

### 4) 변수 선언의 실행 시점 (feat. 호이스팅)
```js
console.log(score); // undefined

var score;
```

위 예제 코드를 엔진이 실행시킨다고 생각해 보자. 윗 줄에서부터 순차적으로 코드를 실행시키므로 먼저 `console.log` 가 실행되어야 하는데, 인자로 받고 있는 `score` 라는 것은 현 단계(첫 줄)에서 아직 선언되지 않은 식별자다. 그러므로 엔진에서 찾을 수 없으니 `ReferenceError` 가 발생해야 하는데, `undefined` 를 출력하며 `console.log` 가 그냥 작동해 버린다.

그 이유는 **변수 선언이 런타임 이전 단계에서 사전 실행되기 때문**이다. 자바스크립트 엔진은 주어진 소스를 바로 한줄씩 실행하는 것이 아니라, `소스코드 평가` 과정을 사전에 거친다. 평가 과정에서 엔진은 **변수 선언을 포함한 모든 선언문**을 소스코드에서 찾아내 먼저 실행한다. 그 다음 이어지는 런타임에서는 평가한 선언문들을 전부 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.

따라서 자바스크립트에서는 변수(뿐 아니라 함수나 클래스 등 까지도)가 코드의 어디에 위치해 있든, 그 **선언** 은 다른 코드에 선행해서 실행된다. 따라서 선언문을 제외한 다른 코드는 식별자가 어디에 있든지 이를 참조할 수 있다. 아직 값이 없는 `undefined` 상태여도 말이다.

이처럼 **변수(식별자) 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 `변수 호이스팅` 이라고 한다.**

<br/>

### 5) 값의 할당
아까 위에서 변수 선언의 앞선 두 단계, 선언과 초기화 단계를 다루었다. 이 두 단계를 거친 변수는 `undefined` 값으로 초기화되어있는 상태다. 이 변수에 사용자는 할당 연산자 `=` 을 사용해서 값을 할당한다. 

```js
var foo;
foo = true;
```

할당은 할당 연산자가 사용된 순간에 이루어진다. 따라서 위의 코드를 `var foo = true;` 라고 단축해서 표현해도, `var foo` 와 ` = true` 는 각기 다른 단계에 해당해서 엔진에 의해 분리된다. 앞서 호이스팅 문제에서 다루었듯, 변수 선언과 값의 할당은 실행 시점이 다르다. 변수 선언은 소스코드 평가 단계에서, 값의 할당은 그 다음인 런타임 단계에서 실행된다. 

#### 변수 초기화, 값의 할당, 그리고 메모리 공간
값을 할당하기 전에 엔진은 변수의 이름을 등록하고 메모리 공간을 확보해서 `undefined` 값으로 초기화한다고 했다. 즉 이 때 할당된 메모리 공간은 `undefined` 값의 크기만큼 확보되어 있다. 이 시점에서는 값의 할당 단계에서 어떤 자료형의 값이 할당될지 아직 알지 못한다. 

당연히 `undefined` 와 새롭게 할당될 값의 메모리상 크기는 다를 수 있다. 즉, 변수에 값이 할당될 때는 초기값 `undefined` 가 저장되어 있던 메모리 공간을 지우고 그 공간에 값을 새롭게 저장하는 것이 아니라 **새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장**하게 된다.

<br/>

### 6) 값의 재할당
```
var foo = 10;
const bar = 20;

foo = 30;
```
`var` 키워드로 선언된 변수 `foo` 에 값 10을 할당했다. 그리고 아래에서 동일한 변수에 새롭게 값 30을 할당했다. 그러면 `undefined` 로 초기화된 변수에 처음 값을 할당할 때와 마찬가지로, 10이 있던 자리에 30을 새롭게 채워넣는 것이 아니라 **값 10이 저장된 메모리 공간은 그대로 두고, 새로운 메모리 공간에 값 30을 저장하고 변수에 매핑한다.** 

여전히 10이 저장되어 있는 메모리 공간은 어떤 값이 들어있으므로 빈 공간은 아니지만, 그렇다고 접근가능하거나 변수에 의해 사용되고 있는 상태도 아니다. 즉 불필요한 값이 된다. 이러한 값들은 `가비지 콜렉터` 에 의해 메모리에서 자동 해제된다. 단, **메모리에서 언제 해제될지는 예측할 수 없다.**

당연히, `const` 키워드로 선언된 변수는 재할당이 불가능하다. 값이 새롭게 할당되는 원리를 반영한다면 '한 번 매핑된 메모리 주소를 변경할 수 없다' 는 뜻으로도 해석해볼 수 있다.

## CH05. 표현식과 문
### 1) 값
우리가 작성하는 대부분의, 정말 90% 이상의 코드는 어떤 '값'을 위해 작성된다. '값'이라는 용어가 당연히 전혀 낯설지는 않지만, 막상 설명하려 하면 난감할 수 있다.
**`값`**이란 어떤 의미인가?

```js
let foo = 10 + 20 // 30
```
**`값` 은 `표현식` 이 `평가` 되어 생성된 결과를 말한다.** 표현식과 평가의 의미도 뒤에서 살펴볼 것이다. 간단히 `평가` 란, 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

위 예제의 `표현식`( 이하 `식` ) 은 `평가` 되어 숫자 **값** `30` 을 생성한다. 모든 값들은 데이터 타입을 갖고 2진수 형태로 저장되며, 이 2진수는 데이터 타입에 따라 각기 다른 값으로 해석된다.

위 예제에서, 변수 `foo` 에 저장된 것은 `10 + 20` 이라는 `식` 이 아니라, 해당 `식` 이 평가된 결과인 `30` 이라는 `값` 이다.

이 `값` 은 다양한 방법으로 생성될 수 있는데, 가장 기본적인 방법은 `리터럴` 을 사용하는 것이다.

<br/>

### 2) 리터럴
`리터럴` 이란, **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**을 말한다고 한다. 간단히 말해 컴퓨터나 엔진이 아니라 <u>'프로그래머가 이해할 수 있는 언어로 짜인 대부분의 코드'</u>를 의미한다. 

```js
let foo = 10 + 20 // 숫자 리터럴 10과 20을 연산해 값 30이 생김
let bar = 30; // 숫자 리터럴 30이 바로 평가되어 값 30이 됨
```

위 예제에서, 변수 `bar` 와 같이 단 하나의 숫자도 `리터럴` 이 될 수 있다. 자바스크립트 엔진은 그 숫자를 평가해 데이터 타입을 갖고 2진수의 형태인 **값** `30`을 만들어내는 것이다.

즉 리터럴은 컴퓨터가 이해할 수 있는 값 이전에 **사람이 이해할 수 있는 문자 또는 미리 약속된 기호**로 표기한 **코드**다. 자바스크립트 엔진은 런타임에 이 `리터럴` 을 `평가` 하여 `값` 을 생성한다. 리터럴은 그 자체로 `표현식` 이다.

<br/>

### 3) 표현식
`표현식` 이란 **값으로 평가될 수 있는 문**이다. 즉 `표현식`  이 `평가` 되면, 새로운 `값` 을 생성하거나 기존 값을 참조한다. 앞서 살펴본 리터럴 역시 엔진에 의해 값으로 평가된다고 했으므로, 이 역시 표현식이다.

기억해둘 점은, **<u>표현식이 평가된 값</u>과 <u>표현식</u>은 동등한 관계, 즉 동치라는 점이다.** 따라서 자바스크립트에서 표현식은 <u>값처럼 사용할 수 있다.</u> 즉, **문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.**

## CH05. 표현식과 문
### 1) 값
우리가 작성하는 대부분의, 정말 90% 이상의 코드는 어떤 '값'을 위해 작성된다. '값'이라는 용어가 당연히 전혀 낯설지는 않지만, 막상 설명하려 하면 난감할 수 있다.
**`값`**이란 어떤 의미인가?

```js
let foo = 10 + 20 // 30
```
**`값` 은 `표현식` 이 `평가` 되어 생성된 결과를 말한다.** 표현식과 평가의 의미도 뒤에서 살펴볼 것이다. 간단히 `평가` 란, 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

위 예제의 `표현식`( 이하 `식` ) 은 `평가` 되어 숫자 **값** `30` 을 생성한다. 모든 값들은 데이터 타입을 갖고 2진수 형태로 저장되며, 이 2진수는 데이터 타입에 따라 각기 다른 값으로 해석된다.

위 예제에서, 변수 `foo` 에 저장된 것은 `10 + 20` 이라는 `식` 이 아니라, 해당 `식` 이 평가된 결과인 `30` 이라는 `값` 이다.

이 `값` 은 다양한 방법으로 생성될 수 있는데, 가장 기본적인 방법은 `리터럴` 을 사용하는 것이다.

<br/>

### 2) 리터럴
`리터럴` 이란, **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**을 말한다고 한다. 간단히 말해 컴퓨터나 엔진이 아니라 <u>'프로그래머가 이해할 수 있는 언어로 짜인 대부분의 코드'</u>를 의미한다. 

```js
let foo = 10 + 20 // 숫자 리터럴 10과 20을 연산해 값 30이 생김
let bar = 30; // 숫자 리터럴 30이 바로 평가되어 값 30이 됨
```

위 예제에서, 변수 `bar` 와 같이 단 하나의 숫자도 `리터럴` 이 될 수 있다. 자바스크립트 엔진은 그 숫자를 평가해 데이터 타입을 갖고 2진수의 형태인 **값** `30`을 만들어내는 것이다.

즉 리터럴은 컴퓨터가 이해할 수 있는 값 이전에 **사람이 이해할 수 있는 문자 또는 미리 약속된 기호**로 표기한 **코드**다. 자바스크립트 엔진은 런타임에 이 `리터럴` 을 `평가` 하여 `값` 을 생성한다. 리터럴은 그 자체로 `표현식` 이다.

<br/>

### 3) 표현식
```js
let x = 1 + 2 // 1 + 2는 평가되어 값 3이 된다.
x + 3 // 6으로 평가된다. 1 + 2와 그 값인 3인 동치이기 때문.
```
`표현식` 이란 **값으로 평가될 수 있는 문**이다. 즉 `표현식`  이 `평가` 되면, 새로운 `값` 을 생성하거나 기존 값을 참조한다. 앞서 살펴본 리터럴 역시 엔진에 의해 값으로 평가된다고 했으므로, 이 역시 표현식이다.

기억해둘 점은, **<u>표현식이 평가된 값</u>과 <u>표현식</u>은 동등한 관계, 즉 동치라는 점이다.** 따라서 자바스크립트에서 표현식은 <u>값처럼 사용할 수 있다.</u> 즉, **문법적으로 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다.**

따라서 표현식은 다른 표현식의 일부가 되어 새로운 값을 만들어낼 수도 있다.

<br/>

### 4) 문
**`문` 이란 프로그램을 구성하는 기본 단위이자 최소 실행 단위다.** 문과 표현식의 차이를 구분하기는 모호한 부분들이 있다. 예를 들어, `var sum = 1 + 2` 는 하나의 문이다. 다만 그 안에서 `var sum` 역시 변수를 선언하는 하나의 **문**(변수 선언문) 이다. 

이렇듯 문은 표현식의 상위 개념으로, **표현식인 문**과 **표현식이 아닌 문**으로 나뉜다. 이 둘을 구분하는 간단한 방법으로는 **변수에 할당해 보는 것**이 있다. 

앞서 `표현식` 은 값으로 평가되어, 그 평가된 값과 표현식 자체는 동치라고 했으므로 표현식인 상태에서 변수에 할당 역시 가능하다고 했다. 그러나 `표현식이 아닌 문` 은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다.

`문` 의 종료를 나타내는 기호로는 `;` 을 사용하고, `{ }` 코드블록 역시 문의 종료를 의미하는 자체 종결성을 지닌다는 점에 유의하면 코드를 읽을 때 의미 단위를 나누는 데 있어 이해도를 높일 수 있을 것이다.

<br/>

## CH06. 데이터 타입

### 1) 자바크스크립트의 7가지 데이터 타입
#### `number`
C나 자바의 경우, 정수와 실수 등 숫자를 구분해서 `int`, `long`, `double` 등 여러 숫자 타입을 제공한다. 하지만 자바스크립트는 단 하나의 숫자 타입만 존재하며 **모든 수를 실수로 처리한다.**

또한 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에, 이들 값을 참조하면 모두 10진수로 해석된다.
```js
let binary = 0b01000001;
let octal = 0o101;
let hex = 0x41;

// 저장된 형태는 각기 다르지만, 모두 10진수 '65'로 출력된다.
console.log(binary);
console.log(octal);
console.log(hex);
```
#### `string`
일반적으로 `'작은따옴표'` 로 텍스트를 감싸서 표현한다.

자바스크립트에서는 문자열이 **원시 타입**이며, 변경 불가능한 값이다.반면 C에서는 문자의 배열로 문자열을 표현하기 때문에 동일한 메모리 주소를 가진 채로 특정 글자에 접근해서 변경하는 것이 가능하다.

따옴표 대신 `백틱` 으로 텍스트를 감싸는 **템플릿 리터럴** 방식을 사용할 수도 있다. 이 표기법은 편리한 문자열 처리 기능들을 제공한다:
- 멀티라인 문자열 (이스케이프 시퀀스 없이 줄바꿈 가능)
- 표현식 삽입 ( `${}` 내부에 표현식 입력 )
  - 이때 표현식의 평가 결과가 문자열이 아니더라도, 문자여롤 타입이 강제 변환되어 삽입된다.

#### `boolean`, `undefined`, `null`
- `boolean` : 논리적 참 거짓. `true` 와 `false`
- `undefined` : `undefined` 가 유일하다. 일반적으로 변수가 선언된 이후 값이 할당된 적이 없음을 나타내는 예약어로 사용되며, 프로그래머가 명시적으로 할당하지는 않는 것이 권장된다.
- `null` : 변수에 값이 없음을 의도적으로 명시할 때 사용된다. 즉 **이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거**하는 것이다. 참조가 제거되어 남겨진 값은 자바스크립트 엔진에 의해 가비지 콜렉션으로 수거될 것이다. 한편으로는 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 `null` 을 반환하기도 한다.

#### `symbol`
변경 불가능한 원시 타입의 값으로, **다른 값과 중복되지 않는 유일무이한 값**이다. 

`symbol` 이외의 원시 값들은 **리터럴**을 통해 생성하지만, `symbol` 은 반드시 `Symbol` 함수를 호출해 생성한다. 이렇게 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다.

```js
let key = Symbol('key');
console.log (typeof key); // symbol

let obj = {};
obj[key] = 'value';
console.log(obj[key]); // value
```

#### 객체 타입
자바스크립트를 이루고 있는 거의 모든 것은 객체다. 위의 6가지 원시 타입 이외에 배열, 함수 등 모든 값은 모두 객체 타입이다.

#### 동적 타이핑
자바스크립트의 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당될 수 있다. 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고, 이후에도 타입을 자유롭게 변경할 수 있다.

즉, 자바스크립트에서는 선언이 아닌 할당에 의해 변수의 타입이 결정된다. 그리고 재할당에 의해 이 타입은 언제든지 동적으로 변할 수 있다. 엄밀히 말하자면 변수가 타입을 갖는 것이 아니라, **값이 타입을 가지기 때문에** 값에 의해 변수의 타입이 동적으로 결정된다고 보는 것이 적절하다.

<br/>

## CH07. 연산자

### 1) `||` : 첫 번째 `truthy` 를 찾는 `OR` 연산자 
```js
result = value1 || value2 || value3;
```
위와 같은 코드에서 OR `||` 연산자는 다음 순서에 따라 연산을 수행한다:
- 가장 왼쪽 피연산자부터 시작해 오른쪽으로 나아가며 피연산자를 평가
- 각 피연산자를 불린형으로 변환
- 변환 후 그 값이 `true` 면 연산을 멈추고, 해당 피연산자의 **변환 전 원래 값**을 반환
- 피연산자 모두를 평가한 경우( = 모든 피연산자가 `false` 로 평가되는 경우 )엔 마지막 피연산자를 반환

여기서 핵심은 반환 값이 형 변환을 하지 않은 원래 값이라는 것이다. 즉, OR `||` 연산자를 여러 개 체이닝(chaining) 하면 첫 번째 `truthy` 를 반환한다. 피연산자에 `truthy` 가 하나도 없다면 마지막 피연산자를 반환한다.

이런 OR 연산자의 추가 기능은 여러 용도로 활용된다. 

#### (1) 변수 또는 표현식으로 구성된 목록에서 첫 번째 `truthy` 얻기

OR `||` 을 사용하면 실제 값이 들어있는 변수를 찾고, 그 값을 보여줄 수 있다. 
```js
let firstName = "";
let lastName = "";
let nickName = "김별명";

alert( firstName || lastName || nickName || "익명"); // 김별명
```

#### (2) 단락 평가(short circuit evaluation)

OR `||` 은 왼쪽부터 시작해서 오른쪽으로 평가를 진행하는데, **`truthy` 를 만나면 나머지 값들은 건드리지 않은 채 평가를 멈춘다.** 이런 프로세스를 '단락 평가’라고 한다.

단락 평가의 동작 방식은 **두 번째 피연산자가 <u>변수 할당과 같은 부수적인 효과(side effect)를 가지는 표현식</u>** 일 때 명확히 볼 수 있다.

```js
true || alert("not executed");
false || alert("executed");
```

위 예시를 실행하면 두 번째 메시지만 출력된다.

첫 번째 줄의 `||` 연산자는 `true` 를 만나자마자 평가를 멈추기 때문에 `alert` 가 실행되지 않는다.

**단락 평가는 연산자 왼쪽 조건이 `falsy` 일 때만 명령어를 실행하고자 할 때 자주 쓰인다.**

### 2) `&&` : 첫 번째 `falsy` 를 찾는 `AND` 연산자 

`AND` 연산자의 작동 방식은 `OR` 연산자의 작동 방식과 유사하다. 차이점은 `AND` 연산자가 첫 번째 `falsy` 를 반환하는 반면, `OR` 은 첫 번째 `truthy` 를 반환한다는 것이다.

즉, `AND` 연산자는 첫 번째 `falsy` 를 반환한다. 피연산자에 `falsy` 가 없다면 마지막 값을 반환한다.

활용 역시 `OR` 연산자와 유사한 방식으로, 변수 또는 표현식으로 구성된 목록에서 첫 번째 `falsy` 를 얻거나 **연산자 왼쪽 조건이 `truthy` 일 때만 명령어를 실행하고자 할 때** 사용된다.


### 💡3) null, undefined 와 비교

<br/>

- `null` 은 대소 비교 시에 숫자 `0` 값으로 암묵적인 타입 변환 되고, 동등 비교시에는 타입 변환이 되지 않는다.

```js
console.log(null >= 0); // true
console.log(null > 0); // false
console.log(null == 0); // false
```

- `undefined` 는 대소 비교 시에 `NaN` 으로 타입이 변환된다.

```js
console.log(undefined > 0); // false
console.log(undefined < 0); // false
console.log(undefined == 0); // false
```

<br />

## CH08. 제어문

### 1) `switch` 문

`switch` 문의 표현식 값과 `case` 문은 **일치 ( `===` )**하는 경우에만 실행흐름을 옮긴다.

아래 코드의 경우 표현식의 값이 `arg = 4` 이지만 `case` 문의 `arg < 5` 는 `true` 값을 가지기 때문에 `default` 문이 실행된다.

```js
arg = 4;
switch (arg) {
  case arg < 5:
    console.log("5 미만입니다.");
    break;

  default:
    console.log("알 수 없는 값입니다.");
}
```

<br/>

### 2) `레이블 문` : 중첩 `for` 문 탈출

중첩 `for`문에서, 외부 `for` 문을 탈출하려면 `레이블` 문을 사용한다.

```js
// 외부 for 문에 레이블 outer 를 지정, 
// break 문에 이 레이블 식별자 outer 를 지정
outer: for (var i = 0; i < 3; i++) {
  for (var j = 0; j < 3; j++) {
    // 원래 내부 for 문의 break 는 오직 내부 for 문만 탈출시킨다.
	// 그러나 여기서는 i + j가 2가 되는 순간 모든 외부 for 문을 탈출할 수 있게 된다.
    if (i + j === 2) break outer;
    console.log('inner valid');
  }
}
```

### 3) 조건문에서 배열의 처리

선언된 배열은 빈 배열이라도 `true` 값으로 간주된다. 

배열은 **참조 자료형**이기 때문에, 변수는 그 배열이 들어 있는 **메모리 주소**를 저장하고 있다. 따라서 배열이 채워져 있는지 여부와는 관계없이, 할당된 순간 그 변수는 가리킬 값(메모리 주소)를 갖고 있으므로 `true` 값으로 평가된다.

```js
const arr = [];

if (arr) {
  console.log(arr); // []
}

arr.push(1);

if (arr) {
  console.log(arr); // [1]
}
```

<br/>

## CH09. 타입 변환과 단축 평가

### 1) 옵셔널 체이닝 연산자와 `null` 병합 연산자

#### `?.` : 옵셔널 체이닝 연산자
좌항이 `null` 또는 `undefined`이 면 `undefined` 를 반환하고, 그렇지 않으면 우항의 프로퍼티 값을 참조한다.

#### `??` : `null` 병합 연산자
좌항이 `null` 또는 `undefined` 이면 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환한다.

<br/>

## 퀴즈

### CH04. 변수 : 호이스팅과 함수
```
console.log(variable)
var variable = "Hi";
console.log(variable)
```
위의 코드를 실행하면, 각각 `undefined` 와 `Hi` 가 출력될 것입니다.
`ReferenceError` 는 발생하지 않습니다.

그러면 변수가 아닌, 함수에서 호이스팅은 어떤 형태로 나타날까요?

아래 코드는 네 가지 방식으로 함수를 작성합니다:
1. `함수 선언식` 으로 작성
2. `const` 키워드 사용, `함수 표현식` 으로 작성
3. `let` 키워드 사용, `화살표 함수` 로 작성
4. `var` 키워드 사용, `화살표 함수` 로 작성

```js
console.log(dec(2,3))
console.log(exp(2,3))
console.log(arrow(2,3))
console.log(arrow2(2,3))

function dec(num, num2) {
  return num + num2;
}

const exp = function(num1, num2) {
  return num + num2;
}

let arrow = (num, num2) => {
	return num + num2;
} 

var arrow2 = (num, num2) => {
	return num + num2;
} 
```

각 함수의 호이스팅 여부 및, 만약 호이스팅이 되지 않는다면 `ReferenceError` 에 의한 것이 맞는지 생각해 봅시다.

<br/>

### CH06. 데이터 타입 : 자료형 예측
```js
typeof(15)

typeof(5.5)

typeof(NaN)

typeof("hello")

typeof(`nice ${2} meet you`)

typeof(true)

typeof(1 != 2)

"foo" + "s"

1 + "3"

"bar" + 5
```
자료형을 예측해 봅시당

<br/>

### CH07. 연산자 + CH09. 타입 변환
#### 1) 다른 형을 가진 값 간의 비교
(1) 숫자와 문자열 자료형 간 비교는 가능할까요?
```js
console.log( '2' > 1 ); 
console.log( '01' == 1 );
```
(2) 각각 `true`, `false` 로 평가되는 값이 동등(`==`) 할 수 있을까요?
```js
let a = 0;
console.log( Boolean(a) ); // false

let b = "0";
console.log( Boolean(b) ); // true

console.log(a == b); // ??
```
<br/>

#### 2) `null` 이나 `undefined` 와 비교하기
(1) `null >= 0` 의 평가값은 `true` 입니다. 그렇다면 아래의 나머지 두 코드 중 어떤 것이 `true` 일까요?
```js
console.log( null >= 0 ); // true
console.log( null > 0 );
console.log( null == 0 );
```
(2) 다음 중 `true` 인 코드를 찾아봅시다. 만약 `false` 라면 어째서인지도 생각해 봅시다.
```js
console.log( undefined > 0 );
console.log( undefined < 0 );
console.log( undefined == 0 );
```

### CH08. 제어문
(1) 아래 코드는 의도대로 작동할까요?
```js
arg = 4
switch (arg) {
  case (arg < 5):
    console.log( '5 미만입니다.' );
    break;

  default:
    console.log( '알 수 없는 값입니다.' );
}
```
(2) 아래 코드를 실행시켜, 값으로 `6` 을 입력하면 어떻게 될까요?
```js
let arg = prompt("값을 입력해주세요.");
switch (arg) {
  case '0':
  case '1':
  case '2':
  case '3':
  case '4':
    console.log( '5 미만입니다.' );
    break;

  case '5':
    console.log( '5입니다.' );
    break;

  case 6:
    console.log( '6입니다.' );
    break;

  default:
    console.log( '알 수 없는 값입니다.' );
}
```
switch 문은 **일치 비교** 로 조건을 확인하므로, 자료형이 중요합니다.

동일한 코드를 if 문으로 작성해 봅시다:
```js
let arg = prompt("값을 입력해주세요.");
if (arg === '0' || arg === '1'
	arg === '2' || arg === '3'
	arg === '4')
    console.log( '5 미만입니다.' );
else if (arg === '5')
    console.log( '5입니다.' );
else if (arg === 6)
    console.log( '6입니다.' );
else
    console.log( '알 수 없는 값입니다.' );
```
조건이 `||` 나 `&&` 로 길어질수록, `case` 로 분리하는 `switch` 문의 가독성이 더 높을 수 있습니다.

하지만 `if` 문을 사용하면 조건의 표현이 보다 자유롭다는 장점이 있습니다. 
만약 `arg` 의 자료형이 문자가 아닌 숫자였다면, `if` 문에서 `if (arg < 5)` 로 훨씬 간결하게 작성할 수 있습니다.

## 스터디 (7/20)
`junseo` 님 문제:
```js
for (var i = 0; i < 6; i++) {
  setTimeout(() => console.log(i), 100);
}

// 6 6 6 6 6 6

for (let i = 0; i < 6; i++) {
  setTimeout(() => console.log(i), 100);
}

// 0 1 2 3 4 5
```
- `var` 로 선언한 변수는 지연되는 100밀리세컨 동안 이미 6까지 다 증가
  - 블록이 아니라 함수 레벨에 바인딩되어 있으므로
  - 오직 하나의 `i` 만 존재한다고 생각
- `let` 으로 선언한 변수는 코드 블록이 반복해서 실행될 때마다 새로운 렉시컬 환경에 바인딩됨
  - 각 환경의 `i` 는 각기 다른 값을 갖고, 유지됨
  - 따라서 i++과 setTimeout이 동일한 렉시컬 환경 내에 있으므로, 매번 1씩 증가해서 출력됨