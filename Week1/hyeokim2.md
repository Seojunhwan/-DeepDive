# Java Script Deep Dive

[4장~9장 문제](https://www.notion.so/4-9-54d7322562aa428293e3bd3483dc152a)

☑️ **04장: 변수**

**4.1 변수란 무엇인가? 왜 필요한가?**

**변수:** 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름. (= 값의 위치를 가리키는 상징적인 이름)

할당: 변수에 값을 저장 (대입, 저장)

참조: 변수에 저장된 값을 읽어들임.

**4.2 식별자**

변수이름 == 식별자 (어떤 값을 구별해서 식별할 수 있는 고유한 이름)

식별자는 값이 아니라 메모리 주소를 기억.

변수, 함수, 클래스 등의 이름은 모두 식별자. (= 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부름)

**4.3 변수 선언**

변수 선언 → 값을 저장하기 위한 메모리 공간 확보, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수 있게 준비

변수 사용하려면 반드시 선언이 필요! → var, let, count 키워드 사용

변수 선언 후 변수에 값 할당안하면? undefined값이 할당되어 초기화. 변수를 사용하려면 반드시 선언이 필요해야. 

**4.4 변수 선언의 실행 시점과 변수 호이스팅**

변수 선언은 런타임 (소스 코드가 한줄씩 순차적으로 실행)이 아니라 **그 이전 단계에 먼저 실행** (소스 코드의 평가 과정에서. 다른 코드보다 먼저 실행됨)

→ 변수 호이스팅: 변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징. + 모든 식별자(var, let, cont, function, function*, class로 선언한)는 호이스팅된다.

**4.5 값의 할당**

할당할 땐 할당연산자 (=) 사용

변수 선언은 런타임 이전에, 값의 할당은 런타임에 실행됨.

- 변수에 값을 할당할 때는 undefined가 저장되어있던 메모리 공간을 지우고 80이 할당되는게 아니라 새로운 메모리 공간을 확보하고 80이 저장됨

**4.6 값의 재할당**

상수: 변수에 저장된 값을 수정할 수 없음.

어떤 식별자와도 연결되어있지 않은 값 → 가비지 콜렉터에 의해 메모리에서 자동해제 (물론 언제 해제될지는 모름)

- 자바스크립트는 매니지드 언어. 메모리의 할당 및 해제를 개발자가 명시적으로 할 수 없음.

**4.7 식별자 네이밍 규칙**

네이밍 규칙: 특수문자 제외한 문자, 숫자, _, $ 포함 가능

숫자로 시작x

예약어 x

네이밍 컨벤션: 카멜 케이스, 스네이크 케이스, 파스칼 케이스, 헝가리언 케이스

[문제]

```jsx
다음 중 식별자로 쓸 수 없는 단어는? (2개)

1. _new
2. 1new1
3. new
4. $new
5. newContent
```

---

☑️ 05장: 표현식과 문

**5.1 값**

값: 식(표현식)이 평가되어 생성된 결과

모든 값은 데이터 타입을 가지며, 메모리에 2진수, 즉 비트의 나열로 저장됨 → 데이터 타입에 따라 다르게 해석될 수 있음. 

`0100 0001 -> 숫자 65 / 문자 'A'`

값은 다양한 방법으로 생성할 수 있다. 가장 기본적인 방법은 리터럴을 사용하는 것.

**5.2 리터럴**

리터럴: 사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글) 또는 약속된 기호(’’, “”, ., [], {}, // 등) 를 사용해 값을 생성하는 표기법. 

(정수 리터럴, 부동소수점 리터럴, 2진수 리터럴, 8진수 리터럴, 16진수 리터럴, 문자열 리터럴, 불리언 리터럴, null 리터럴, undefined 리터럴, 객체 리터럴, 배열 리터럴, 함수 리터럴, 정규 표현식 리터럴)

**5.3 표현식**

표현식: 값으로 평가될 수 있는 문. 표현식이 평가되면 **새로운 값을 생성하거나 기존 값을 참조**한다. 값으로 평가될 수 있는 문은 모두 표현식! 

**5.4 문**

문: 프로그램을 구성하는 기본단위이자 최소 실행단위 → 프로그램은 문의 집합으로 이뤄짐

**문**은 여러 **토큰**으로 구성 → **토큰**이란? 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소. (ex 키워드, 식별자, 연산자, 리터럴, 세미콜론, 마침표 등)

문 = 선언문, 할당문, 조건문, 반복문 등

**5.5 세미콜론과 세미콜론 자동 삽입 기능**

문의 끝에 붙이는 세미콜론은 옵션. 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여줌 (ASI) → 그치만 개발자의 예측과 일치하지 않을때도 있으니 이 책에서는 붙인다.

**5.6 표현식인 문과 표현식이 아닌 문**

표현식인 문 vs 표현식이 아닌 문

구별법? 변수에 할당해보기. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.

`var foo = var x;`

표현식인 문은 값처럼 사용가능

```jsx
var foo = x = 100
console.log(foo); //100
```

[문제]

```jsx
다음 중 표현식이 아닌 것은?
1. var score = 100;
2. 50 + 50
3. 'score'
4. 50
5. score() //선언 없음
6. score; //선언 있음
```

---

☑️ 06장: 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 갖고, 7개의 데이터 타입을 제공한다

원시 타입(숫자, 문자열, 불리언, undefined, null, 심벌)과 객체 타입(객체, 함수, 배열 등)으로 분리가능

**6.1 숫자 타입**

🌟 자바스크립트는 독특하게 하나의 숫자타입만 존재. 모든 수를 실수로 처리!

(나에겐 너무 어려운 말) 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다.

- 정수로 표시되는 수끼리 나누더라도 실수가 나올 수 있다.

`1 === 1.0 //true`

`3 / 2 -> 1.5`

- 숫자 타입은 세가지 특별한 값도 포함 가능

Infinity : 양의 무한대 / -Infinity: 음의 무한대 / NaN (산술 연산 불가)

- 자바스크립트는 대소문자를 구별 (nan, Nan 이런거 불가. 식별자로 해석함)

**6.2 문자열 타입**

문자열 표기 방법: “”, ‘’, ``

문자열은 원시 타입, 변경 불가능한 값임

**6.3 템플릿 리터럴**

템플릿 리터럴은 백틱(``)을 사용하여 표현

- 6.3.1 멀티라인 문자열
    
    일반 문자열 내에서 줄바꿈 허용 안됨. 백슬래시\로 시작하는 이스케이프 시퀀스를 사용해야 함
    
    하지만 템플릿 리터럴은 가능!
    
- 6.3.2 표현식 삽입
    
    문자열은 문자열 연산자 +를 사용해 연결가능. +는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작. 그 외에는 덧셈 연산자로 동작.
    
    `‘My name is ‘ +  first + ‘ ‘ + last + ‘.’`
    
    표현식을 삽입하려면?
    
    ``My name is ${first} ${last}.``
    
    `${}`로 표현식을 감싼다. 표현식의 결과가 문자열이 아니더라도 문자열로 타입이 강제 변환됨
    

6.4 불리언 타입

true, false

6.5 undefined 타입

undefined를 개발자가 의도적으로 변수에 할당하는 것? 좋지 않아.

변수에 값이 없다는 걸 명시하고 싶을 땐 null을 할당하자.

6.6 null 타입

자바스크립트는 대소문자 구분하므로 null, Null, NULL은 다 다름

null을 할당했다는 건? 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미.

→ 자바스크립트는 이에 대해 가비지 콜렉션 수행.

함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도.

6.7 심벌 타입

ES6에서 추가됨. 변경불가능한 원시타입의 값. 

다른 값과 중복되지 않는 유일무이한 값. 

객체의 유일한 프로퍼티 키를 만들기 위해 사용.

심벌은 Symbol 함수를 호출해 생성한다. 이 때 생성된 심벌값은 외부에 노출되지 않음.

`var key = Symbol(’key’)`

6.8 객체 타입

중요한 것은 자바스크립트는 객체 기반의 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것. 지금까지 데이터 타입 외의 값은 모두 객체 타입임!

6.9 데이터 타입의 필요성

- 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조
    - 자바스크립트는 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다.
    
    ex) `var score = 100`
    
    리터럴 100을 숫자 타입의 값으로 해석하고 숫자 타입의 값 100을 저장하기 위해 8바이트의 메모리 공간을 확보한다. 그리고 100을 2진수로 저장한다.
    
    - 값을 참조하는 경우
    
    식별자 score을 통해 100이 저장되어있는 메모리 공간의 주소를 찾아갈 수 있다.
    
    값을 참조하려면 읽어 들여야 할 메모리 공간의 크기를 알아야함! 자바스크립트는 score 변수에 숫자타입의 값이 할당되어있으므로 숫자 타입으로 인식, 8바이트 단위로 메모리 공간에 저장된 값을 읽어들임.
    
- 6.9.2 데이터 타입에 의한 값의 해석
    - score 변수를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석함
    
    **데이터 타입이 필요한 이유?**
    
    1) 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해
    
    2) 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
    
    3) 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해 
    

6.10 동적 타이핑

- 6.10.1 동적 타입 언어와 정적 타입 언어
    - 자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다. → 어더한 타입의 값이라도 자유롭게 할당할 수 있다.
    - typeof로 데이터 타입 판단 가능! (문자열로 알려줌)
    
    **→ 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정 (타입 추론) 된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. / 동적 타이핑** 
    
    현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다.
    
- 6.10.2 동적 타입 언어와 변수
    - 변수를 사용할 때 주의 사항
    
    1) 필요한 경우에 한해 제한적으로 사용한다. 언제든지 재할당되어 값이 변할 수 있기에
    
    2) 변수의 유효범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
    
    3) 전역 변수는 최대한 사용하지 않도록 한다.
    
    4) 변수보다는 상수를 사용해 값의 변경을 억제한다.
    
    5) 변수 이름은 목적이나 의미를 파악할 수 있도록 네이밍 한다.
    

[문제]

```jsx
다음 중 코드를 실행시킨 결과가 다른 문항과 다른 것은?
1. console.log('2 + 3 = 5');
2. console.log('2 + 3 = '+ 5);
3. console.log('2 + 3 = '+ 2 + 3);
4. console.log(`2 + 3 = ` ${2 + 3});
```

---

☑️ 07장: 연산자

산술, 할당, 비교, 논리, 타입, 지수

피연산자: 값이라는 명사 역할

연산자: 피연사자를 연산하여 새로운 값을 만든다라는 동사역할

7.1 산술 연산자

산술연산 불가능한 경우 NaN을 반환

- 7.1.1 이항 산술 연산자
    - +  -  *  /  % (부수효과 x)
- 7.1.2 단항 산술 연산자
    - ++   --  (부수효과o)   +   - (부수효과x)
    - **숫자 타입이 아닌 피연산자에 + 단항 연산자를 사용하면 피 연산자를 숫자 타입으로 변환하여 치환함. 피연산자를 변환하는 게 아니라 새로운 값을 생성하여 반환하므로 부수효과는 없음**
    - - 는 피연산자의 부호를 반전한 값을 반환
- 7.1.3 문자열 연결 연산자
    - + 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 작동한다.
    
    `‘1’ + 2; // 12`
    `1 + 2 // 3`
    
    - 그 외에는 산술 연산자로 동작
    
    `1 + true // 2`
    
    - undefined는 숫자로 타입 변환되지 않는다.
    - 이렇게 강제 변환하는 걸 압묵적 타입변환 또는 타입 강제 변환이라고 한다.
    

7.2 할당 연산자

=   +=   -=   *=   /=  %=

할당문도 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

고로 할당문을 다른 변수에 할당할 수도.

`a = b = c = 0;`

7.3 비교 연산자

- 7.3.1 동등/일치 비교 연산자
    - 동등 비교 / 부동등 비교 (==, ≠) : 느슨함 → 압묵적 타입 변환을 통해 타입을 일치 시키고 비교
    - 일치 비교 / 불일치 비교 (===, ≠=) : 타입까지 같아야함.
    - NaN === NaN (false) → NaN은 자신과 일치하지않는 유일한값
    - 0 === -0; (true) → 양과 음의 0을 비교하면 true 반환함
    - [Object.is](http://Object.is) 메서드로 아주 정확하게 비교할 수 있음
    
- 7.3.2 대소 관계 비교 연산자
    
     >  <  ≥  ≤
    

7.4 삼항 조건 연산자

조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값

0은 false, 1은 true

→ if else 문으로 바꿀 수 있음.

삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.

7.5 논리 연산자

|| 논리합

&& 논리곱

! 부정

```jsx
true || true // true
true || false // true
false || true // true
false || false // false

true && true // true
true && false // false
false && true // fasle
false && false // false

!true // false
!false // true
```

논리합 또는 논리곱 연산자의 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합 또는 논리곱 연산자의 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.

7.6 쉼표 연산자

마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

7.7 그룹 연산자

(). 연산자 우선순위가 가장 높다.

7.8 typeof 연산자

typeof가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지않다.

- typeof 연산자로 null 값을 연산해보면 null이 아닌 object를 반환한다. 따라서 값이 null 타입인지 확인할 땐 ===로
- 선언하지 않은 식별자를 typeof 연산자로 연산하면 referenceError가 발생하지 않고 undefined를 반환한다.

7.9 지수 연산자

밑 ** 지수

음수를 거듭제곱의 밑으로 사용해 계산하려면 음수를 괄호로 묶어야

지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다.

7.10 그 외의 연산자

?   ??   delete   new   instanceof   in

7.11 연산자의 부수 효과

부수효과가 있는 연산자 → 할당 연산자, 증가/감소 연산자, delete 연산자

7.12 연산자 우선순위

7.13 연산자 결합 순서

[문제]

```jsx
다음 중 결과가 실제와 다른 것은?
1. console.log(1 + 2) //3
2. console.log('1' + 2) // 12
3. console.log(NaN === NaN) //false
4. console.log(0 === -0) //true
5. console.log(1 && 2) // 2
6. console.log(1 || 2) // 2
```

---

☑️ 08장: 제어문

8.1 블록문

```jsx
{
	var foo = 10;
}
```

**블록문:** 0개 이상의 문을 중괄호로 묶은 것.

자바스크립트는 블록문을 하나의 실행 단위로 취급한다.

문의 끝에는 세미콜론을 붙이는 게 일반적이지만, 블록문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 세미콜론 안 붙임!!

8.2 조건문

- 8.2.1 if...else 문

```jsx
var num = 2;
var kind;

if (num > 0) kind = '양수';
else if (num < 0) kind = '음수';
else kind = '영';
```

→ 삼항 연산자로 바꿔쓸 수 있음.

```jsx
//0은 false로 취급한다.
var kind = num ? (num > 0 ? '양수' : '음수') : '영';
```

- 8.2.2 switch 문

```jsx
switch (표현식) {
	case 표현식1:
		switch 문의 표현식과 표현식 1이 일치하면 실행될 문;
		break;
	case 표현식2:
		switch 문의 표현식과 표현식 2가 일치하면 실행될 문;
		break;
	default:
		switch 문의 표현식과 일치하는 case문이 없을때 실행될 문;
}
```

break가 없으면 모든 case문을 실행하는 폴스루가 일어남.

8.3 반복문

- 8.3.1 for 문
- 8.3.2 while 문
- 8.3.3 do...while 문
    
    코드 블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드 블록은 무조건 한번 이상 실행된다.
    
    ```jsx
    var count = 0;
    
    //count가 3보다 작을때까지 코드 블록을 계속 반복 실행
    do {
    	console.log(count);
    	count++;
    }
    while (count < 3);
    ```
    

8.4 break 문

break문은 코드 블록을 탈출한다. 레이블문, 반복문, switch문의 코드 블록외에 break문을 사용하면 문법 에러 발생!

레이블 문이란? 식별자가 붙은 문.

8.5 continue 문

[문제]

```jsx
// 아래의 for문이 무한루프를 돌지 않게 하기 위해 빈칸에 들어갈 문은?

outer: for (var i = 0; i< 3; i++)
{
	for(var j = 0; j < 3; j++)
	{
		if (i + j === 2)
		[     빈칸     ]
	}
}

답: 
```

---

☑️ 09장: 타입 변환과 단축 평가

9.1 타입 변환이란?

9.2 암묵적 타입 변환

- 9.2.1 문자열 타입으로 변환
- 9.2.2 숫자 타입으로 변환
- 9.2.3 불리언 타입으로 변환

9.3 명시적 타입 변환

- 9.3.1 문자열 타입으로 변환
- 9.3.2 숫자 타입으로 변환
- 9.3.3 불리언 타입으로 변환

9.4 단축 평가

- 9.4.1 논리 연산자를 사용한 단축 평가
- 9.4.2 옵셔널 체이닝 연산자
- 9.4.3 null 병합 연산자

[문제]

```jsx
다음 중 결과가 실제와 다른 것은?
1. console.log(!0) // true
2. console.log(+'50') // '50'
3. console.log(50 + '') // '50'
4. console.log(!!'50') // true
5. console.log(50 && false) //false
```